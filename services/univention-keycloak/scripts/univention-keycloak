#!/usr/bin/python3


from keycloak import KeycloakAdmin
from univention.config_registry import ConfigRegistry
from keycloak.exceptions import KeycloakError, raise_error_from_response, KeycloakGetError
from argparse import ArgumentParser, Namespace
import requests
from xml.etree import ElementTree
import json
from subprocess import Popen, PIPE
from base64 import b64decode

PEM_CERT_HEADER = "-----BEGIN CERTIFICATE-----\n"
PEM_CERT_FOOTER = "-----END CERTIFICATE-----\n"


def check_and_create_component(kc_client, name, prov_id, payload_):
	ldap_component_filter = {'name': name, 'providerId': prov_id}
	ldap_component_list = kc_client.get_components(ldap_component_filter)
	if not ldap_component_list:
		kc_client.create_component(payload=payload_)
		ldap_component_list = kc_client.get_components(ldap_component_filter)

	ldap_component = ldap_component_list.pop()
	return ldap_component.get("id")


def get_realm_id(kc_client, name):
	ldap_realms_list = kc_client.get_realms()
	# search for realm "name"
	realm_info = list(filter(lambda realm: realm["realm"] == name, ldap_realms_list))
	# return realm id
	return realm_info[0]["id"]


def extract_endpoints_xml(metadata_url):
	xml_content = requests.get(metadata_url, verify=False).content  # FIXME: remove verify False
	saml_descriptor_xml = ElementTree.fromstring(xml_content)
	logout_endpoint = saml_descriptor_xml.find('.//{urn:oasis:names:tc:SAML:2.0:metadata}SingleLogoutService').attrib["Location"]
	acs_endpoint = saml_descriptor_xml.find('.//{urn:oasis:names:tc:SAML:2.0:metadata}AssertionConsumerService').attrib["Location"]

	endpoints = {"logout": logout_endpoint, "acs": acs_endpoint}
	return endpoints


def create_SAML_client(opt):
	print("CREATING KEYCLOAK SAML CLIENT.....")
	ucr = ConfigRegistry()
	ucr.load()
	hostname = ucr.get("hostname")
	domain = ucr.get("domainname")

	# derived composite vars #
	if hostname and not hostname == "unassigned-hostname":
		server_fqdn_without_subdomain = "https://{}.{}".format(hostname, domain)
	else:
		server_fqdn_without_subdomain = "https://{}".format(domain)

	# guess default urls #
	# TODO: how useful/generically valid is this?
	client_id = server_fqdn_without_subdomain + "/{}/apps/user_saml/saml/metadata".format(opt.app)
	valid_redirect_urls = [server_fqdn_without_subdomain + "/{}/apps/user_saml/saml/*".format(opt.app)]
	single_logout_service_url_post = server_fqdn_without_subdomain + "/{}/apps/user_saml/saml/sls".format(opt.app)
	single_logout_service_url_redirect = server_fqdn_without_subdomain + "/{}/apps/user_saml/saml/sls".format(opt.app)
	assertion_consumer_url_post = server_fqdn_without_subdomain + "/{}/apps/user_saml/saml/acs".format(opt.app)

	if opt.metadata_url:  # FIXME: Cleanup in the future
		client_id = opt.metadata_url
		valid_redirect_urls = [client_id[:client_id.rfind("/") + 1:] + "*"]
		endpoints = extract_endpoints_xml(client_id)
		# build urls #
		single_logout_service_url_post = endpoints["logout"]
		single_logout_service_url_redirect = endpoints["logout"]
		assertion_consumer_url_post = endpoints["acs"]

	client_payload_saml = {
		"clientId": client_id,
		"surrogateAuthRequired": False,
		"enabled": True,
		"alwaysDisplayInConsole": False,
		"clientAuthenticatorType": "client-secret",
		"redirectUris": valid_redirect_urls,
		"webOrigins": [],
		"notBefore": 0,
		"bearerOnly": False,
		"consentRequired": False,
		"standardFlowEnabled": True,
		"implicitFlowEnabled": False,
		"directAccessGrantsEnabled": True,
		"serviceAccountsEnabled": False,
		"publicClient": True,
		"frontchannelLogout": True,
		"protocol": "saml",
		"attributes": {
			"saml_name_id_format": "transient",
			"saml.multivalued.roles": "false",
			"saml.force.post.binding": "true",
			"oauth2.device.authorization.grant.enabled": "false",
			"backchannel.logout.revoke.offline.tokens": "false",
			"saml.server.signature.keyinfo.ext": "false",
			"use.refresh.tokens": "true",
			"oidc.ciba.grant.enabled": "false",
			"backchannel.logout.session.required": "true",
			"client_credentials.use_refresh_token": "false",
			"saml.signature.algorithm": "RSA_SHA256",
			"saml.client.signature": "false",
			"require.pushed.authorization.requests": "false",
			"id.token.as.detached.signature": "false",
			"saml.assertion.signature": "true",
			"saml_single_logout_service_url_post": single_logout_service_url_post,
			"saml.encrypt": "false",
			"saml_assertion_consumer_url_post": assertion_consumer_url_post,
			"saml.server.signature": "true",
			"exclude.session.state.from.auth.response": "false",
			"saml.artifact.binding.identifier": "JOtItQNol3ThXjMMWI3gcbW92sU=",
			"saml.artifact.binding": "false",
			"saml_single_logout_service_url_redirect": single_logout_service_url_redirect,
			"saml_force_name_id_format": "false",
			"tls.client.certificate.bound.access.tokens": "false",
			"acr.loa.map": "{}",
			"saml.authnstatement": "true",
			"display.on.consent.screen": "false",
			"saml.assertion.lifespan": "300",
			"token.response.type.bearer.lower-case": "false",
			"saml.onetimeuse.condition": "false",
			"saml_signature_canonicalization_method": "http://www.w3.org/2001/10/xml-exc-c14n#"
		},
		"authenticationFlowBindingOverrides": {},
		"fullScopeAllowed": True,
		"nodeReRegistrationTimeout": -1,
		"protocolMappers": [
			{
				"name": "userid_mapper",
				"protocol": "saml",
				"protocolMapper": "saml-user-attribute-mapper",
				"consentRequired": False,
				"config": {
					"aggregate.attrs": "",
					"attribute.name": "uid",
					"attribute.nameformat": "Basic",
					"friendly.name": "uid",
					"user.attribute": "uid"
				}
			},
			{
				"config": {
					"attribute.name": "Role",
					"attribute.nameformat": "Basic",
					"friendly.name": "role list mapper",
					"single": "true"
				},
				"name": "role_list_mapper",
				"protocol": "saml",
				"protocolMapper": "saml-role-list-mapper"
			}
		],
		"defaultClientScopes": [
		],
		"optionalClientScopes": [],
		"access": {
			"view": True,
			"configure": True,
			"manage": True
		}
	}

	if opt.client_signature_required:
		client_payload_saml["attributes"]["saml.client.signature"] = "true"

	# build kc admin session #
	if opt.keycloak:
		kc_admin_auth_url = opt.keycloak
		kc_admin_auth_url.replace("https", "http")
	else:
		kc_admin_auth_url = "http://127.0.0.1:8180"

	kc_admin_user = "admin"
	if opt.keycloak_pwd == "":
		pwdfile = "/etc/keycloak.secret"
		with open(pwdfile, 'r') as fd:
			kc_admin_pass = fd.read().strip()
	else:
		#kc_admin_pass = opt.keycloak_pwd
		with open(opt.keycloak_pwd, 'r') as fd:
			kc_admin_pass = fd.read().strip()

	# realm config #
	realm_name = "ucs"
	default_realm = "master"

	print("Using KC_URL: {}".format(kc_admin_auth_url))

	# log into default realm in case UCS realm doesn't exist yet #
	kc_admin = KeycloakAdmin(server_url=kc_admin_auth_url, username=kc_admin_user, password=kc_admin_pass, realm_name=realm_name, user_realm_name=default_realm, verify=True)

	kc_admin.create_client(payload=client_payload_saml, skip_exists=True)


def create_oidc_client(opt):
	print("CREATING KEYCLOAK OIDC CLIENT.....")
	ucr = ConfigRegistry()
	ucr.load()
	hostname = ucr.get("hostname")
	domain = ucr.get("domainname")

	# derived composite vars #
	if hostname and not hostname == "unassigned-hostname":
		server_fqdn_without_subdomain = "https://{}.{}".format(hostname, domain)
	else:
		server_fqdn_without_subdomain = "https://{}".format(domain)

	# build urls #
	valid_redirect_urls = [opt.app_url, server_fqdn_without_subdomain]

	client_payload_oidc = {
		"clientId": opt.client_id,
		"rootUrl": opt.app_url,
		"adminUrl": "",
		"baseUrl": opt.app_url,
		"surrogateAuthRequired": False,
		"enabled": True,
		"alwaysDisplayInConsole": False,
		"clientAuthenticatorType": "client-secret",
		"redirectUris": valid_redirect_urls,
		"webOrigins": valid_redirect_urls,
		"notBefore": 0,
		"bearerOnly": False,
		"consentRequired": False,
		"standardFlowEnabled": True,
		"implicitFlowEnabled": False,
		"directAccessGrantsEnabled": True,
		"serviceAccountsEnabled": False,
		"publicClient": False,
		"frontchannelLogout": True,
		"protocol": "openid-connect",
		"attributes": {
			"saml.multivalued.roles": "false",
			"saml.force.post.binding": "false",
			"frontchannel.logout.session.required": "false",
			"oauth2.device.authorization.grant.enabled": "false",
			"backchannel.logout.revoke.offline.tokens": "false",
			"saml.server.signature.keyinfo.ext": "false",
			"use.refresh.tokens": "true",
			"oidc.ciba.grant.enabled": "false",
			"backchannel.logout.session.required": "false",
			"client_credentials.use_refresh_token": "false",
			"saml.client.signature": "false",
			"require.pushed.authorization.requests": "false",
			"saml.allow.ecp.flow": "false",
			"saml.assertion.signature": "false",
			"id.token.as.detached.signature": "false",
			"client.secret.creation.time": "1661514856",
			"saml.encrypt": "false",
			"saml.server.signature": "false",
			"exclude.session.state.from.auth.response": "false",
			"saml.artifact.binding": "false",
			"saml_force_name_id_format": "false",
			"tls.client.certificate.bound.access.tokens": "false",
			"acr.loa.map": "{}",
			"saml.authnstatement": "false",
			"display.on.consent.screen": "false",
			"token.response.type.bearer.lower-case": "false",
			"saml.onetimeuse.condition": "false",
		},
		"authenticationFlowBindingOverrides": {},
		"fullScopeAllowed": True,
		"nodeReRegistrationTimeout": -1,
		"protocolMappers": [
			{
				"name": "uid",
				"protocol": "openid-connect",
				"protocolMapper": "oidc-usermodel-attribute-mapper",
				"consentRequired": False,
				"config": {
					"userinfo.token.claim": "true",
					"user.attribute": "uid",
					"id.token.claim": "true",
					"access.token.claim": "true",
					"claim.name": "uid",
					"jsonType.label": "String"
				}
			},
			{
				"name": "username",
				"protocol": "openid-connect",
				"protocolMapper": "oidc-usermodel-property-mapper",
				"consentRequired": False,
				"config": {
					"userinfo.token.claim": "true",
					"user.attribute": "username",
					"id.token.claim": "true",
					"access.token.claim": "true",
					"claim.name": "preferred_username",
					"jsonType.label": "String"
				}
			},
			{
				"name": "email",
				"protocol": "openid-connect",
				"protocolMapper": "oidc-usermodel-property-mapper",
				"consentRequired": False,
				"config": {
					"userinfo.token.claim": "true",
					"user.attribute": "email",
					"id.token.claim": "true",
					"access.token.claim": "true",
					"claim.name": "email",
					"jsonType.label": "String"
				}
			}
		],
		"defaultClientScopes": [
			"web-origins",
			"acr",
			"profile",
			"roles",
			"email"
		],
		"optionalClientScopes": [
			"address",
			"phone",
			"offline_access",
			"microprofile-jwt"
		],
		"access": {
			"view": True,
			"configure": True,
			"manage": True
		},
		"authorizationServicesEnabled": ""
	}

	if opt.client_secret:
		client_payload_oidc["secret"] = opt.client_secret

	# build kc admin session #
	if opt.keycloak:
		kc_admin_auth_url = opt.keycloak
		kc_admin_auth_url.replace("https", "http")
	else:
		kc_admin_auth_url = "http://127.0.0.1:8180"

	kc_admin_user = "admin"
	if opt.keycloak_pwd == "":
		pwdfile = "/etc/keycloak.secret"
		with open(pwdfile, 'r') as fd:
			kc_admin_pass = fd.read().strip()
	else:
		# kc_admin_pass = opt.keycloak_pwd
		with open(opt.keycloak_pwd, 'r') as fd:
			kc_admin_pass = fd.read().strip()

	# realm config #
	realm_name = "ucs"
	default_realm = "master"

	print("Using KC_URL: {}".format(kc_admin_auth_url))

	# log into default realm in case UCS realm doesn't exist yet #
	kc_admin = KeycloakAdmin(server_url=kc_admin_auth_url, username=kc_admin_user, password=kc_admin_pass, realm_name=realm_name, user_realm_name=default_realm, verify=True)

	kc_admin.create_client(payload=client_payload_oidc, skip_exists=True)


def modify_client_scope_mapper(opt):
	if opt.keycloak:
		kc_admin_auth_url = opt.keycloak
		kc_admin_auth_url.replace("https", "http")
	else:
		kc_admin_auth_url = "http://127.0.0.1:8180"

	kc_admin_user = "admin"
	if opt.keycloak_pwd == "":
		pwdfile = "/etc/keycloak.secret"
		with open(pwdfile, 'r') as fd:
			kc_admin_pass = fd.read().strip()
	else:
		# kc_admin_pass = opt.keycloak_pwd
		with open(opt.keycloak_pwd, 'r') as fd:
			kc_admin_pass = fd.read().strip()

	# realm config #
	realm_name = "ucs"
	default_realm = "master"

	print("Using KC_URL: {}".format(kc_admin_auth_url))

	# log into default realm in case UCS realm doesn't exist yet #
	kc_admin = KeycloakAdmin(server_url=kc_admin_auth_url, username=kc_admin_user, password=kc_admin_pass, realm_name=realm_name, user_realm_name=default_realm, verify=True)

	scopes = kc_admin.get_client_scopes()
	id_role_list = [scope["id"] for scope in scopes if scope["name"] == "role_list"][0]

	params_path = {"realm-name": realm_name, "scope-id": id_role_list}
	data_raw = kc_admin.raw_get(
		"admin/realms/{realm-name}/client-scopes/{scope-id}/protocol-mappers/models".format(**params_path)
	)
	mappers = data_raw.json()

	mapper_test = [mapper for mapper in mappers if mapper["name"] == "role list"][0]
	id_mapper_role_list = [mapper["id"] for mapper in mappers if mapper["name"] == "role list"][0]

	mapper_test["config"]["single"] = True
	params_path = {
		"realm-name": realm_name,
		"scope-id": id_role_list,
		"protocol-mapper-id": id_mapper_role_list,
	}

	data_raw = kc_admin.raw_put(
		"admin/realms/{realm-name}/client-scopes/{scope-id}/protocol-mappers/models/{protocol-mapper-id}".format(**params_path),
		data=json.dumps(mapper_test),
	)


def download_cert_oidc(opt):
	print("Downloading KEYCLOAK OIDC CERT.....")
	ucr = ConfigRegistry()
	ucr.load()

	if opt.oidc_url:
		oidc_conf_url = opt.oidc_url
	else:
		oidc_conf_url = "https://{}/realms/ucs/.well-known/openid-configuration".format(ucr.get("keycloak/server/sso/fqdn"))

	oidc_conf = requests.get(oidc_conf_url)
	certs_oidc = oidc_conf.json()["jwks_uri"]
	oidc_cert_json = requests.get(certs_oidc).json()

	cert_list = [key["x5c"][0] for key in oidc_cert_json["keys"] if key["use"] == "sig"]
	cert = cert_list[0] + "\n"

	if opt.as_pem:
		cert_der = b64decode(cert)
		p = Popen(['openssl', 'x509', '-inform', 'DER', '-out', opt.output, '-outform', 'PEM'], stdin=PIPE)
		p.communicate(input=cert_der)
	else:
		with open(opt.output, 'w') as f:
			f.write(cert)


def download_cert_saml(opt):
	print("Downloading KEYCLOAK SAML CERT.....")
	ucr = ConfigRegistry()
	ucr.load()

	if opt.saml_url:
		saml_descriptor_url = opt.saml_url
	else:
		saml_descriptor_url = "https://{}/realms/ucs/protocol/saml/descriptor".format(ucr.get("keycloak/server/sso/fqdn"))

	saml_descriptor = requests.get(saml_descriptor_url)
	saml_descriptor_xml = ElementTree.fromstring(saml_descriptor.content)

	cert = saml_descriptor_xml.find('.//{http://www.w3.org/2000/09/xmldsig#}X509Certificate').text + "\n"

	if opt.as_pem:
		cert_der = b64decode(cert)
		p = Popen(['openssl', 'x509', '-inform', 'DER', '-out', opt.output, '-outform', 'PEM'], stdin=PIPE)
		p.communicate(input=cert_der)
	else:
		with open(opt.output, 'w') as f:
			f.write(cert)


def get_client_secret(opt):
	print("Obtaining secret for client ...")

	kc_admin_user = "admin"
	if opt.keycloak_pwd == "":  # TODO: pass pwd file ?
		pwdfile = "/etc/keycloak.secret"
		with open(pwdfile, 'r') as fd:
			kc_admin_pass = fd.read().strip()
	else:
		#kc_admin_pass = opt.remotePwd
		#kc_admin_pass = opt.keycloak_pwd
		with open(opt.keycloak_pwd, 'r') as fd:
			kc_admin_pass = fd.read().strip()

	if opt.keycloak:
		kc_admin_auth_url = opt.keycloak
		kc_admin_auth_url.replace("https", "http")
	else:
		kc_admin_auth_url = "http://127.0.0.1:8180"
	print("Using KC_URL: {}".format(kc_admin_auth_url))

	# realm config #
	realm_name = "ucs"
	default_realm = "master"

	kc_admin = KeycloakAdmin(server_url=kc_admin_auth_url, username=kc_admin_user, password=kc_admin_pass, realm_name=realm_name, user_realm_name=default_realm, verify=True)
	kc_admin.realm_name = "ucs"

	print(kc_admin.get_client_secrets(kc_admin.get_client_id(opt.client_name)))


def parse_args(args=None):
	# type: (list[str]) -> Namespace
	"""
	Parse command line arguments.

	:param args: the list of arguments to process (default: `sys.argv[1:]`)
	:returns: a Namespace instance.
	"""

	parser = ArgumentParser(description=__doc__)
	parser.add_argument("--binddn", default="Administrator")
	parser.add_argument("--bindpwdfile", default="univention")
	parser.add_argument("--keycloak-pwd", default="")
	parser.add_argument("--keycloak", default="")
	parser.add_argument("--remotePwd", default="")
	subparsers = parser.add_subparsers(title="subcommands", description="valid subcommands", required=True, dest="command")

	parser_saml = subparsers.add_parser("saml/sp", help="configure a SAML SP")
	operation_subparsers = parser_saml.add_subparsers(title="operation", description="valid subcommands", required=True, dest="operation")
	create_saml_parser = operation_subparsers.add_parser("create", help="create a new SAML SP in Keycloak")
	create_saml_parser.add_argument("app", metavar='APPNAME')
	create_saml_parser.add_argument("--client-signature-required", action="store_true")
	create_saml_parser.add_argument("--metadata-url", default="")
	create_saml_parser.set_defaults(func=create_SAML_client)

	parser_oidc = subparsers.add_parser("oidc/rp", help="configure a OIDC RP")
	operation_subparsers = parser_oidc.add_subparsers(title="operation", description="valid subcommands", required=True, dest="operation")
	create_oidc_parser = operation_subparsers.add_parser("create", help="create a new OIDC client in Keycloak")
	create_oidc_parser.add_argument("client_id", metavar='CLIENT_ID')
	create_oidc_parser.add_argument("--client-secret", default="")
	create_oidc_parser.add_argument("--app-url", required=True)
	create_oidc_parser.set_defaults(func=create_oidc_client)

	create_saml_parser = operation_subparsers.add_parser("secret", help="get client secret from Keycloak")
	create_saml_parser.add_argument("--client-name", required=True)
	create_saml_parser.set_defaults(func=get_client_secret)

	parser_saml_idp_cert = subparsers.add_parser("saml/idp/cert", help="SAML IdP certificate")
	operation_subparsers = parser_saml_idp_cert.add_subparsers(title="operation", description="valid subcommands", required=True, dest="operation")
	get_cert_saml_parser = operation_subparsers.add_parser("get", help="download the SAML IdP signing certificate")
	get_cert_saml_parser.add_argument("--as-pem", action='store_true')
	get_cert_saml_parser.add_argument("--saml-url", default="")
	get_cert_saml_parser.add_argument("--output", required=True)
	get_cert_saml_parser.set_defaults(func=download_cert_saml)

	parser_oidc_op_cert = subparsers.add_parser("oidc/op/cert", help="OIDC provider certificate")
	operation_subparsers = parser_oidc_op_cert.add_subparsers(title="operation", description="valid subcommands", required=True, dest="operation")
	get_cert_oidc_parser = operation_subparsers.add_parser("get", help="download the OIDC signing certificate")
	get_cert_oidc_parser.add_argument("--as-pem", action='store_true')
	get_cert_oidc_parser.add_argument("--oidc-url", default="")
	get_cert_oidc_parser.add_argument("--output", required=True)
	get_cert_oidc_parser.set_defaults(func=download_cert_oidc)

	init_parser = subparsers.add_parser("init", help="configure a Keycloak app")
	init_parser.add_argument("--reverse-proxy-url", default="")
	init_parser.add_argument("--ldap", default="")
	init_parser.add_argument("--bind-user", default="")
	init_parser.add_argument("--bind-pwd", default="")
	init_parser.set_defaults(func=config)

	adhoc_parser = subparsers.add_parser("ad-hoc", help="configure the ad-hoc federation login flow")
	operation_subparsers = adhoc_parser.add_subparsers(title="operation", description="valid subcommands", required=True, dest="operation")
	adhoc_parser_opp = operation_subparsers.add_parser("enable", help="create a login flow that uses ad-hoc federation")
	adhoc_parser_opp.add_argument("--udm-user", required=True)
	adhoc_parser_opp.add_argument("--udm-pwd", required=True)
	adhoc_parser_opp.set_defaults(func=create_adhoc_flow)
	adhoc_parser_opp = operation_subparsers.add_parser("create", help="create and configure an Identity Provider")
	adhoc_parser_opp.add_argument("--alias", default="ADFS", required=True)
	adhoc_parser_opp.add_argument("--metadata-url", required=True)
	adhoc_parser_opp.set_defaults(func=create_IdP)

	fa_parser = subparsers.add_parser("2fa", help="configure 2FA on a group given by --group-2fa (default: \"2FA group\")")
	operation_subparsers = fa_parser.add_subparsers(title="operation", description="valid subcommands", required=True, dest="operation")
	adhoc_parser_opp = operation_subparsers.add_parser("enable", help="create a login flow that uses 2FA and activate it")
	adhoc_parser_opp.add_argument("--group-2fa", default="2FA group")
	adhoc_parser_opp.set_defaults(func=enable_2fa)

	opt = parser.parse_args(args)

	return opt


def create_IdP(opt):
	print("Creating ad hoc federation identity provider...")
	ucr = ConfigRegistry()
	ucr.load()

	kc_admin_user = "admin"
	if opt.keycloak_pwd == "":  # TODO: pass pwd file ?
		pwdfile = "/etc/keycloak.secret"
		with open(pwdfile, 'r') as fd:
			kc_admin_pass = fd.read().strip()
	else:
		kc_admin_pass = opt.remotePwd
		#kc_admin_pass = opt.keycloak_pwd
		with open(opt.keycloak_pwd, 'r') as fd:
			kc_admin_pass = fd.read().strip()

	if opt.keycloak:
		kc_admin_auth_url = opt.keycloak
		kc_admin_auth_url.replace("https", "http")
	else:
		kc_admin_auth_url = "http://127.0.0.1:8180"
	print("Using KC_URL: {}".format(kc_admin_auth_url))

	# realm config #
	realm_name = "ucs"
	default_realm = "master"

	kc_admin = KeycloakAdmin(server_url=kc_admin_auth_url, username=kc_admin_user, password=kc_admin_pass, realm_name=realm_name, user_realm_name=default_realm, verify=True)
	kc_admin.realm_name = "ucs"

	metadata_info = extract_metadata(opt.metadata_url)

	idp_payload = {
		"addReadTokenRoleOnCreate": False,
		"alias": opt.alias,
		"authenticateByDefault": False,
		"config": {
			"addExtensionsElementWithKeyInfo": "false",
			"allowCreate": "true",
			"allowedClockSkew": "",
			"attributeConsumingServiceIndex": "",
			"authnContextComparisonType": "exact",
			"backchannelSupported": "",
			"encryptionPublicKey": metadata_info["encryption"],
			"entityId": "keycloak_ucs",
			"forceAuthn": "false",
			"hideOnLoginPage": "",
			"loginHint": "false",
			"nameIDPolicyFormat": "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified",
			"postBindingAuthnRequest": "true",
			"postBindingLogout": "false",
			"postBindingResponse": "true",
			"principalAttribute": "sAMAccountName",
			"principalType": "ATTRIBUTE",
			"signatureAlgorithm": "RSA_SHA256",
			"signingCertificate": metadata_info["signing"],
			"signSpMetadata": "false",
			"singleSignOnServiceUrl": metadata_info["sso_logout_url"],
			"syncMode": "IMPORT",
			"useJwksUrl": "true",
			"validateSignature": "true",
			"wantAssertionsEncrypted": "false",
			"wantAssertionsSigned": "false",
			"wantAuthnRequestsSigned": "true",
			"xmlSigKeyInfoKeyNameTransformer": "CERT_SUBJECT"
		},
		"displayName": opt.alias,
		"enabled": True,
		"firstBrokerLoginFlowAlias": "Univention-Authenticator ad hoc federation flow",
		"linkOnly": False,
		"postBrokerLoginFlowAlias": "",
		"providerId": "saml",
		"storeToken": False,
		"trustEmail": False,
		"updateProfileFirstLoginMode": "on"
	}
	kc_admin.create_idp(idp_payload)

	mapper_payload = {
		"config": {
			"attribute.friendly.name": "",
			"attribute.name": "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress",
			"attributes": "[]",
			"syncMode": "IMPORT",
			"user.attribute": "email"
		},
		"identityProviderAlias": opt.alias,
		"identityProviderMapper": "saml-user-attribute-idp-mapper",
		"name": "email"
	}
	kc_admin.add_mapper_to_idp(opt.alias, mapper_payload)

	mapper_payload = {
		"config": {
			"attribute.friendly.name": "",
			"attribute.name": "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname",
			"attributes": "[]",
			"syncMode": "IMPORT",
			"user.attribute": "firstName"
		},
		"identityProviderAlias": opt.alias,
		"identityProviderMapper": "saml-user-attribute-idp-mapper",
		"name": "firstName"
	}
	kc_admin.add_mapper_to_idp(opt.alias, mapper_payload)

	mapper_payload = {
		"config": {
			"attribute.friendly.name": "",
			"attribute.name": "objectGuid",
			"attributes": "[]",
			"syncMode": "IMPORT",
			"user.attribute": ucr.get("keycloak/federation/remote/identifier")
		},
		"identityProviderAlias": opt.alias,
		"identityProviderMapper": "saml-user-attribute-idp-mapper",
		"name": "remoteIdentifier"
	}
	kc_admin.add_mapper_to_idp(opt.alias, mapper_payload)

	mapper_payload = {
		"config": {
			"attribute.friendly.name": "",
			"attribute.name": "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname",
			"attributes": "[]",
			"syncMode": "IMPORT",
			"user.attribute": "lastName"
		},
		"identityProviderAlias": opt.alias,
		"identityProviderMapper": "saml-user-attribute-idp-mapper",
		"name": "lastName"
	}
	kc_admin.add_mapper_to_idp(opt.alias, mapper_payload)

	mapper_payload = {
		"config": {
			"attribute": "sourceID",
			"attribute.value": "ADFS",
			"attributes": "[]",
			"syncMode": "INHERIT"
		},
		"identityProviderAlias": opt.alias,
		"identityProviderMapper": "hardcoded-attribute-idp-mapper",
		"name": ucr.get("keycloak/federation/source/identifier")
	}
	kc_admin.add_mapper_to_idp(opt.alias, mapper_payload)

	mapper_payload = {
		"config": {
			"attributes": "[]",
			"syncMode": "IMPORT",
			"target": "LOCAL",
			"template": "external-${ALIAS}-${ATTRIBUTE.sAMAccountName}"
		},
		"identityProviderAlias": opt.alias,
		"identityProviderMapper": "saml-username-idp-mapper",
		"name": "username mapper"
	}
	kc_admin.add_mapper_to_idp(opt.alias, mapper_payload)


def extract_metadata(metadata_url):
	xml_content = requests.get(metadata_url, verify=False).content  # FIXME: remove verify False
	saml_descriptor_xml = ElementTree.fromstring(xml_content)
	signing_cert = saml_descriptor_xml.find('.//{http://www.w3.org/2000/09/xmldsig#}X509Certificate').text
	encryption_cert = saml_descriptor_xml.findall(".//{http://www.w3.org/2000/09/xmldsig#}X509Certificate")[1].text
	sso_url = saml_descriptor_xml.find('.//{urn:oasis:names:tc:SAML:2.0:metadata}SingleLogoutService').attrib["Location"]

	metadata_info = {"encryption": encryption_cert, "signing": signing_cert, "sso_logout_url": sso_url}
	return metadata_info


def enable_2fa(opt):
	print("Enabling 2FA ...")
	# load UCR
	ucr = ConfigRegistry()
	ucr.load()
	ldap_base = ucr.get("ldap/base")

	kc_admin_user = "admin"
	if opt.keycloak_pwd == "":  # TODO: pass pwd file ?
		pwdfile = "/etc/keycloak.secret"
		with open(pwdfile, 'r') as fd:
			kc_admin_pass = fd.read().strip()
	else:
		kc_admin_pass = opt.remotePwd
		#kc_admin_pass = opt.keycloak_pwd
		with open(opt.keycloak_pwd, 'r') as fd:
			kc_admin_pass = fd.read().strip()

	if opt.keycloak:
		kc_admin_auth_url = opt.keycloak
		kc_admin_auth_url.replace("https", "http")
	else:
		kc_admin_auth_url = "http://127.0.0.1:8180"
	print("Using KC_URL: {}".format(kc_admin_auth_url))

	# realm config #
	realm_name = "ucs"
	default_realm = "master"

	kc_admin = KeycloakAdmin(server_url=kc_admin_auth_url, username=kc_admin_user, password=kc_admin_pass, realm_name=realm_name, user_realm_name=default_realm, verify=True)
	kc_admin.realm_name = "ucs"
	realm_2fa_role = "2FA role"
	ldap_2fa_group = opt.group_2fa   # FIXME: Check group to use for 2FA

	ldap_component_filter = {'name': 'ldap-provider', 'providerId': 'ldap'}
	ldap_component_list = kc_admin.get_components(ldap_component_filter)
	provider = ldap_component_list.pop()
	mapper_id = add_or_replace_ldap_group_mapper(kc_admin, provider, "univention-groups", ldap_2fa_group, ldap_base)

	# Synchronize LDAP groups to Keycloak
	param_path = {"ldap-provider-id": provider["id"], "id-mapper": mapper_id}
	kc_admin.raw_post("/admin/realms/ucs/user-storage/{ldap-provider-id}/mappers/{id-mapper}/sync?direction=fedToKeycloak".format(**param_path), {})

	create_realm_role(kc_admin, realm_name, realm_2fa_role)
	create_realm_group(kc_admin, realm_name, ldap_2fa_group)  # FIXME: This could be removed if we only use UDM groups
	assign_group_realm_role_by_group_name(kc_admin, realm_name, ldap_2fa_group, realm_2fa_role)

	# switch to default flow before changing anything #
	flow_name = "2fa-browser"
	kc_admin.update_realm(realm_name, {"browserFlow": "browser"})

	# create browser flow #
	create_conditional_2fa_flow(kc_admin, realm_name, realm_2fa_role, flow_name)

	# change authentication binding to conditional 2fa flow #
	kc_admin.update_realm(realm_name, {"browserFlow": flow_name})


def create_or_replace_realm_role(kc_admin, realm, role):
	REALM_ROLE_BASE = {
		"name": None,
		"composite": False,
		"clientRole": False,
		# "containerId": None,
		"attributes": {}
	}

	# check for existing role #
	roles = kc_admin.get_realm_roles()
	for iter_role in roles:
		if role == iter_role["name"]:
			kc_admin.delete_realm_role(role)

	# create payload #
	payload = REALM_ROLE_BASE
	payload["name"] = role
	#payload["containerId"] = role

	param_path = {"REALM": realm}
	url = "admin/realms/{REALM}/roles".format(**param_path)
	data_raw = kc_admin.raw_post(url, data=json.dumps(payload))
	return raise_error_from_response(data_raw, KeycloakGetError, expected_codes=[204, 201])


def create_realm_role(kc_admin, realm, role):
	REALM_ROLE_BASE = {
		"name": None,
		"composite": False,
		"clientRole": False,
		# "containerId": None,
		"attributes": {}
	}

	# check for existing role #
	roles = kc_admin.get_realm_roles()
	for iter_role in roles:
		if role == iter_role["name"]:
			print("Group already exists")  # Avoid deleting the role, it will cause to unbind role from groups already bind
			return
			# kc_admin.delete_realm_role(role)

	# create payload #
	payload = REALM_ROLE_BASE
	payload["name"] = role
	#payload["containerId"] = role

	param_path = {"REALM": realm}
	url = "admin/realms/{REALM}/roles".format(**param_path)
	data_raw = kc_admin.raw_post(url, data=json.dumps(payload))
	return raise_error_from_response(data_raw, KeycloakGetError, expected_codes=[204, 201])


def create_realm_group(kc_admin, realm, group):
	"""
	Create or replace if exists a realm group
	:param kc_admin: Keycloak client
	:param realm: String
	:param group: String
	:return: Keycloak server response (RealmRepresentation)
	"""

	REALM_GROUP_BASE = {
		"name": None
	}

	# check for existing group #
	groups = kc_admin.get_groups()
	for iter_group in groups:
		if group == iter_group["name"]:
			print("Group already exists")  # Avoid deleting the group, it will cause to unbind ldap users if the group already exists
			return
			# kc_admin.delete_group(iter_group["id"])

	# create payload #
	payload = REALM_GROUP_BASE
	payload["name"] = group
	# payload["containerId"] = realm

	return kc_admin.create_group(payload)


def assign_group_realm_role_by_group_name(kc_admin, realm, group_name, role):
	"""
	Assign a keycloak realm role to a group by it's name (rather than it's internal id).
	Users in this group will automatically be part of the assinged role.
	:param kc_admin: Keycloak client
	:param realm: String
	:param group_name: String
	:param role: String
	:return: Keycloak server response (RealmRepresentation)
	"""

	group_id = None
	groups = kc_admin.get_groups()  # query={"name": group_name}
	groups = [group for group in groups if group["name"] == group_name]
	print(groups)

	if not groups:
		print("Warning: Groupname does not exist, realm role can not be linked")
		return
	for g in groups:
		if g["name"] == group_name:
			group_id = g["id"]

	# get role id #
	realm_role_id = None
	for r in kc_admin.get_realm_roles():
		if r["name"] == role:
			realm_role_id = r["id"]
			break
	if not realm_role_id:
		print("WARNING: role {} does not exist".format(role))
		return

	payload = [
		{
			"id": realm_role_id,
			"containerId": realm,
			"clientRole": False,
			"name": role
		}
	]

	param_path = {"REALM": realm, "GROUP_ID": group_id}
	data_raw = kc_admin.raw_post("admin/realms/{REALM}/groups/{GROUP_ID}/role-mappings/realm".format(**param_path), data=json.dumps(payload))
	return raise_error_from_response(data_raw, KeycloakGetError, expected_codes=[204])


def add_or_replace_ldap_group_mapper(kc_admin, ldap_sp, name, ldap_group, ldap_base):
	"""
	Add or replace if exists component mapper of type ldap-attribute-mapper
	:param kc_admin: Keycloak client
	:param ldap_sp: KeycloakREST_LDAPComponentRepresentation
	:param name: String
	:param ldap_group: String
	:param ldap_base: String
	:return: Keycloak server response (RealmRepresentation)
	"""
	LDAP_GROUP_MAPPER = {
		"name": None,
		"parentId": None,
		"providerId": "group-ldap-mapper",
		"providerType": "org.keycloak.storage.ldap.mappers.LDAPStorageMapper",
		"config": {
			"membership.attribute.type": [
				"UID"
			],
			"group.name.ldap.attribute": [
				"cn"
			],
			"preserve.group.inheritance": [
				"false"
			],
			"membership.user.ldap.attribute": [
				"uid"
			],
			"groups.dn": [
				None
			],
			"mode": [
				"READ_ONLY"
			],
			"user.roles.retrieve.strategy": [
				"LOAD_GROUPS_BY_MEMBER_ATTRIBUTE"
			],
			"ignore.missing.groups": [
				"false"
			],
			"membership.ldap.attribute": [
				"memberUid"
			],
			"memberof.ldap.attribute": [
				"memberOf"
			],
			"group.object.classes": [
				"univentionGroup"
			],
			"groups.path": [
				"/"
			],
			"drop.non.existing.groups.during.sync": [
				"false"
			]
		}
	}

	payload = LDAP_GROUP_MAPPER
	payload["parentId"] = ldap_sp["id"]
	payload["name"] = name
	payload["config"]["groups.dn"] = ["cn=groups,{}".format(ldap_base)]

	add_or_replace_mapper(kc_admin, component=payload)

	mapper_component_filter = {'name': name, 'parentId': payload['parentId']}
	component_list = kc_admin.get_components(mapper_component_filter)
	return component_list[0]["id"]


def add_or_replace_mapper(kc_admin, component):
	"""
	Add or replace if exists any component mapper
	:param kc_admin: Keycloak client
	:param component: KeycloakREST_ComponentRepresentation
	:return:  Keycloak server response (RealmRepresentation)
	"""

	mapper_component_filter = {'name': component["name"], 'parentId': component['parentId']}
	component_list = kc_admin.get_components(mapper_component_filter)
	for mapper in component_list:
		kc_admin.delete_component(mapper["id"])

	return kc_admin.create_component(payload=component)


def create_conditional_2fa_flow(kc_admin, realm, conditional_role, flow_name):
	"""
	Create a conditional 2FA-require authentication flow for a given role
	:param kc_admin: Keycloak client
	:param realm: String
	:param conditional_role: String
	:param flow_name: String
	:return: None
	"""

	# delete old flow/subflows #
	flows = kc_admin.get_authentication_flows()
	for f in flows:
		if f["alias"].startswith(flow_name):
			delete_authentication_flow(kc_admin, f["id"])
			print("Deleted: ", f["alias"])

	# copy default browser flow #
	kc_admin.copy_authentication_flow(payload=json.dumps({"newName": flow_name}), flow_alias="browser")

	# create role condition #
	master_subflow = "{} Browser - Conditional OTP".format(flow_name)
	payload = {"provider": "conditional-user-role", "requirement": "REQUIRED"}
	kc_admin.create_authentication_flow_execution(payload=json.dumps(payload), flow_alias=master_subflow)

	# determine user role execution id #
	condition_user_role_id = None
	for exe in kc_admin.get_authentication_flow_executions(flow_name):
		if exe.get("authenticationFlow"):
			continue
		if exe["providerId"] == "conditional-user-role":
			condition_user_role_id = exe["id"]

	# raise role condition prio (twice) #
	execution_raise_priority(kc_admin, condition_user_role_id)
	execution_raise_priority(kc_admin, condition_user_role_id)

	# FIXME: bug in keycloak API means requirement = REQUIRED can not be set at creation #
	# if this bug is fixed the following lines may be deleted #
	payload_update_required_state = {
		"id": condition_user_role_id,
		"requirement": "REQUIRED"
	}
	try:
		kc_admin.update_authentication_flow_executions(payload=json.dumps(payload_update_required_state), flow_alias=flow_name)
	except KeycloakGetError as e:
		if e.response_code != 202:
			raise e
	# FIXME end #

	# config role condition #
	config = {
		"alias": "2fa-role-mapping",
		"config": {
			"condUserRole": conditional_role,
			"negate": ""
		}
	}
	create_config_for_execution(kc_admin, config, condition_user_role_id)

	# disable user configured #
	condition_user_configured_id = None
	for exe in kc_admin.get_authentication_flow_executions(flow_name):
		if exe.get("authenticationFlow"):
			continue
		if exe["providerId"] == "conditional-user-configured":
			condition_user_configured_id = exe["id"]

	payload_condition_user = {"id": condition_user_configured_id, "requirement": "DISABLED"}

	# FIXME: keycloak API bug, responds with 202
	try:
		kc_admin.update_authentication_flow_executions(json.dumps(payload_condition_user), flow_name)
	except KeycloakGetError as e:
		if e.response_code != 202:
			raise e


def create_config_for_execution(kc_admin, config, execution_id):
	"""
	Create an extended config for an existing flow execution
	:param kc_admin: Keycloak client
	:param config: KeycloakREST_ExecutionConfigRepresentation
	:param execution_id: String
	:return: Keycloak server response (RealmRepresentation)
	"""

	param_path = {"REALM": kc_admin.realm_name, "EXECUTION_ID": execution_id}
	url = "admin/realms/{REALM}/authentication/executions/{EXECUTION_ID}/config".format(**param_path)
	data_raw = kc_admin.raw_post(url, data=json.dumps(config))
	return raise_error_from_response(data_raw, KeycloakGetError, expected_codes=[204, 201])


def delete_authentication_flow(kc_admin, flow_id):
	params_path = {"realm-name": kc_admin.realm_name, "id": flow_id}
	data_raw = kc_admin.raw_delete("admin/realms/{realm-name}/authentication/flows/{id}".format(**params_path))
	return raise_error_from_response(data_raw, KeycloakError, expected_codes=[204])


def execution_raise_priority(kc_admin, execution_id):
	"""
	Raise the priority of a give execution within it's subflow.
	Calling this for the top priority execution has no effect, but will not fail.
	:param kc_admin: Keycloak client
	:param execution_id: String
	:return: Keycloak server response (RealmRepresentation)
	"""

	payload = {"realm": kc_admin.realm_name, "execution": execution_id}

	param_path = {"REALM": kc_admin.realm_name, "EXECUTION_ID": execution_id}
	url = "admin/realms/{REALM}/authentication/executions/{EXECUTION_ID}/raise-priority".format(**param_path)
	data_raw = kc_admin.raw_post(url, data=json.dumps(payload))
	return raise_error_from_response(data_raw, KeycloakGetError, expected_codes=[204, 201])


def create_adhoc_flow(opt):
	print("Creating ad hoc federation authentication flow...")

	kc_admin_user = "admin"
	if opt.keycloak_pwd == "":  # TODO: pass pwd file ?
		pwdfile = "/etc/keycloak.secret"
		with open(pwdfile, 'r') as fd:
			kc_admin_pass = fd.read().strip()
	else:
		kc_admin_pass = opt.remotePwd
		#kc_admin_pass = opt.keycloak_pwd
		with open(opt.keycloak_pwd, 'r') as fd:
			kc_admin_pass = fd.read().strip()

	if opt.keycloak:
		kc_admin_auth_url = opt.keycloak
		kc_admin_auth_url.replace("https", "http")
	else:
		kc_admin_auth_url = "http://127.0.0.1:8180"
	print("Using KC_URL: {}".format(kc_admin_auth_url))

	# realm config #
	realm_name = "ucs"
	default_realm = "master"

	kc_admin = KeycloakAdmin(server_url=kc_admin_auth_url, username=kc_admin_user, password=kc_admin_pass, realm_name=realm_name, user_realm_name=default_realm, verify=True)
	kc_admin.realm_name = "ucs"
	# load UCR
	ucr = ConfigRegistry()
	ucr.load()
	hostname = ucr.get("hostname")
	domain = ucr.get("domainname")

	payload_authflow = {
		"newName": "Univention-Authenticator ad hoc federation flow"
	}

	list_flows = kc_admin.get_authentication_flows()
	flow_fbl = list(filter(lambda flow: flow["alias"] == 'first broker login', list_flows))[0]

	print(flow_fbl)
	kc_admin.copy_authentication_flow(payload=json.dumps(payload_authflow), flow_alias='first broker login')

	payload_exec_flow = {
		'provider': "univention-authenticator"
	}
	kc_admin.create_authentication_flow_execution(payload=json.dumps(payload_exec_flow), flow_alias='Univention-Authenticator ad hoc federation flow')

	execution_list = kc_admin.get_authentication_flow_executions("Univention-Authenticator ad hoc federation flow")
	ua_execution = list(filter(lambda flow: flow["displayName"] == 'Univention Authenticator', execution_list))[0]
	print(ua_execution)

	payload_exec_flow = {
		"id": ua_execution["id"],
		"requirement": "REQUIRED",
		"displayName": "Univention Authenticator",
		"requirementChoices": [
			"REQUIRED",
			"DISABLED"
		],
		"configurable": "true",
		"providerId": "univention-authenticator",
		"level": 0,
		"index": 2
	}
	try:
		kc_admin.update_authentication_flow_executions(payload=json.dumps(payload_exec_flow), flow_alias='Univention-Authenticator ad hoc federation flow')
	except KeycloakError as e:
		print(e)
		if e.response_code != 202:  # FIXME: function expected 204 response it gets 202
			raise e

	# config_id from 'authenticationConfig' in get_authentication_flow_executions
	config_ua = {
		"config": {
			"udm_endpoint": "http://{}.{}/univention/udm".format(hostname, domain),
			"udm_user": opt.UDM_user,
			"udm_password": opt.UDM_pwd
		},
		"alias": "localhost config"
	}

	#  check raise error
	data_raw = kc_admin.raw_post("admin/realms/{}/authentication/executions/{}/config".format(kc_admin.realm_name, ua_execution["id"]), json.dumps(config_ua))
	print("Response code from config Univention-Authenticator: ", data_raw.status_code)


def config(opt):
	# load UCR
	ucr = ConfigRegistry()
	ucr.load()
	hostname = ucr.get("hostname")
	domain = ucr.get("domainname")
	locales_ucr = ucr.get("locale").split()
	locales_format = [locale[:locale.index("_")] for locale in locales_ucr]
	default_locale_ucr = ucr.get("locale/default")
	default_locale = default_locale_ucr[:default_locale_ucr.index("_")]

	ldap_hostdn = ucr.get("ldap/hostdn")
	user_dn = ldap_hostdn[ldap_hostdn.index(",dc="):][1:]

	role = ucr.get("server/role")
	if role == "domaincontroller_master":
		pwdfile = "/etc/idp-ldap-user.secret"
		with open(pwdfile, 'r') as fd:
			kc_service_pass = fd.read().strip()
		kc_service_user = "sys-idp-user"

		bind_dn = "uid={udm_service_user},cn=users,{user_dn}".format(udm_service_user=kc_service_user, user_dn=user_dn)

	else:
		bind_dn = opt.binddn
		with open(opt.bindpwdfile, 'r') as fd:
			kc_service_pass = fd.read().strip()

	if opt.bind_user:
		kc_service_user = opt.bind_user

	if opt.bind_pwd:
		kc_service_pass = opt.bind_pwd

	kc_admin_user = "admin"
	if opt.keycloak_pwd == "":  # TODO: pass pwd file ?
		pwdfile = "/etc/keycloak.secret"
		with open(pwdfile, 'r') as fd:
			kc_admin_pass = fd.read().strip()
	else:
		kc_admin_pass = opt.remotePwd
		#kc_admin_pass = opt.keycloak_pwd
		with open(opt.keycloak_pwd, 'r') as fd:
			kc_admin_pass = fd.read().strip()

	# realm config #
	realm_name = "ucs"
	default_realm = "master"

	# client config #
	client_id_location = "/univention/saml/metadata"
	valid_redirect_urls = ""

	# user federation
	if opt.ldap:
		ucs_ldap_url = opt.ldap
	else:
		ucs_ldap_url = "ldap://{}.{}:7389".format(hostname, domain)  # "ldap://{FQDN}:{port}"

	print("Using bind-dn: {}".format(bind_dn))

	# derived composite vars #
	if hostname and not hostname == "unassigned-hostname":
		server_fdnq_without_subdomain = "https://{}.{}".format(hostname, domain)
	else:
		server_fdnq_without_subdomain = "https://{}".format(domain)

	if opt.reverse_proxy_url and opt.keycloak:
		server_fdnq_without_subdomain = opt.reverse_proxy_url

	# valid redirect uris #
	if valid_redirect_urls:
		valid_redirect_urls = valid_redirect_urls
	else:
		valid_redirect_urls = [server_fdnq_without_subdomain + "/univention/saml/"]

	# build kc admin session #
	if opt.keycloak:
		kc_admin_auth_url = opt.keycloak
		kc_admin_auth_url.replace("https", "http")
	else:
		kc_admin_auth_url = "http://127.0.0.1:8180"
	print("Using KC_URL: {}".format(kc_admin_auth_url))

	# log into default realm in case UCS realm doesn't exist yet #
	kc_admin = KeycloakAdmin(server_url=kc_admin_auth_url, username=kc_admin_user, password=kc_admin_pass, realm_name=realm_name, user_realm_name=default_realm, verify=True)

	# set locale languages #
	realm_payload = {
		"id": default_realm,
		"realm": default_realm,
		"enabled": True,
		"internationalizationEnabled": True,
		"supportedLocales": locales_format,
		"defaultLocale": default_locale,
		"adminTheme": "keycloak",
		"accountTheme": "keycloak",
		"emailTheme": "keycloak",
		"loginTheme": "UCS",
		"browserSecurityHeaders": {
			"contentSecurityPolicyReportOnly": "",
			"xContentTypeOptions": "nosniff",
			"xRobotsTag": "none",
			"xFrameOptions": "",
			"contentSecurityPolicy": "frame-src 'self'; frame-ancestors 'self' {}/univention; object-src 'none';".format(server_fdnq_without_subdomain),
			"xXSSProtection": "1; mode=block",
			"strictTransportSecurity": "max-age=31536000; includeSubDomains"
		}
	}
	kc_admin.update_realm(default_realm, payload=realm_payload)

	# create ucs realm #
	realm_payload["id"] = realm_name
	realm_payload["realm"] = realm_name
	kc_admin.create_realm(payload=realm_payload, skip_exists=True)

	# create client #
	client_id = server_fdnq_without_subdomain + client_id_location
	print("Client ID: {}".format(client_id))

	# build urls #
	single_logout_service_url_post = server_fdnq_without_subdomain + "/univention/saml/slo/"
	single_logout_service_url_redirect = server_fdnq_without_subdomain + "/univention/saml/slo/"
	assertion_consumer_url_post = server_fdnq_without_subdomain + "/univention/saml/"

	client_payload_portal = {
		"clientId": client_id,
		"surrogateAuthRequired": False,
		"enabled": True,
		"alwaysDisplayInConsole": False,
		"clientAuthenticatorType": "client-secret",
		"redirectUris": valid_redirect_urls,
		"webOrigins": [],
		"notBefore": 0,
		"bearerOnly": False,
		"consentRequired": False,
		"standardFlowEnabled": True,
		"implicitFlowEnabled": False,
		"directAccessGrantsEnabled": True,
		"serviceAccountsEnabled": False,
		"publicClient": True,
		"frontchannelLogout": True,
		"protocol": "saml",
		"attributes": {
			"saml.multivalued.roles": "false",
			"saml.force.post.binding": "true",
			"oauth2.device.authorization.grant.enabled": "false",
			"backchannel.logout.revoke.offline.tokens": "false",
			"saml.server.signature.keyinfo.ext": "false",
			"use.refresh.tokens": "true",
			"oidc.ciba.grant.enabled": "false",
			"backchannel.logout.session.required": "true",
			"client_credentials.use_refresh_token": "false",
			"saml.signature.algorithm": "RSA_SHA256",
			"saml.client.signature": "false",
			"require.pushed.authorization.requests": "false",
			"id.token.as.detached.signature": "false",
			"saml.assertion.signature": "true",
			"saml_single_logout_service_url_post": single_logout_service_url_post,
			"saml.encrypt": "false",
			"saml_assertion_consumer_url_post": assertion_consumer_url_post,
			"saml.server.signature": "true",
			"exclude.session.state.from.auth.response": "false",
			"saml.artifact.binding.identifier": "JOtItQNol3ThXjMMWI3gcbW92sU=",
			"saml.artifact.binding": "false",
			"saml_single_logout_service_url_redirect": single_logout_service_url_redirect,
			"saml_force_name_id_format": "false",
			"tls.client.certificate.bound.access.tokens": "false",
			"acr.loa.map": "{}",
			"saml.authnstatement": "true",
			"display.on.consent.screen": "false",
			"saml.assertion.lifespan": "300",
			"token.response.type.bearer.lower-case": "false",
			"saml.onetimeuse.condition": "false",
			"saml_signature_canonicalization_method": "http://www.w3.org/2001/10/xml-exc-c14n#"
		},
		"authenticationFlowBindingOverrides": {},
		"fullScopeAllowed": True,
		"nodeReRegistrationTimeout": -1,
		"protocolMappers": [
			{
				"name": "userid_mapper",
				"protocol": "saml",
				"protocolMapper": "saml-user-attribute-mapper",
				"consentRequired": False,
				"config": {
					"attribute.nameformat": "URI Reference",
					"user.attribute": "uid",
					"friendly.name": "uid",
					"attribute.name": "urn:oid:0.9.2342.19200300.100.1.1"
				}
			}
		],
		"defaultClientScopes": [
			"role_list"
		],
		"optionalClientScopes": [],
		"access": {
			"view": True,
			"configure": True,
			"manage": True
		}
	}
	kc_admin.create_client(payload=client_payload_portal, skip_exists=True)

	# user federation ldap provider payload#
	ldap_federation_payload = {
		"name": "ldap-provider",
		"providerId": "ldap",
		"providerType": "org.keycloak.storage.UserStorageProvider",
		"parentId": get_realm_id(kc_admin, realm_name),
		"config": {
			"pagination": ["true"],
			"fullSyncPeriod": ["-1"],
			"startTls": ["false"],
			"connectionPooling": ["true"],
			"usersDn": [user_dn],
			"cachePolicy": ["MAX_LIFESPAN"],
			"maxLifespan": ["300000"],
			"useKerberosForPasswordAuthentication": ["false"],
			"importEnabled": ["false"],
			"enabled": ["true"],
			"bindCredential": [kc_service_pass],
			"bindDn": [bind_dn],
			"changedSyncPeriod": ["-1"],
			"usernameLDAPAttribute": ["uid"],
			"vendor": ["other"],
			"uuidLDAPAttribute": ["entryUUID"],
			"allowKerberosAuthentication": ["false"],
			"connectionUrl": [ucs_ldap_url],
			"syncRegistrations": ["false"],
			"authType": ["simple"],
			"debug": ["false"],
			"searchScope": ["2"],
			"useTruststoreSpi": ["ldapsOnly"],
			"usePasswordModifyExtendedOp": ["true"],
			"trustEmail": ["false"],
			"priority": ["0"],
			"userObjectClasses": ["inetOrgPerson, organizationalPerson"],
			"rdnLDAPAttribute": ["uid"],
			"editMode": ["READ_ONLY"],
			"validatePasswordPolicy": ["false"],
			"batchSizeForSync": ["1000"]
		}
	}

	# find existing ldap provider or just create if none exists #
	ldap_component_id = check_and_create_component(kc_admin, ldap_federation_payload["name"], ldap_federation_payload["providerId"], ldap_federation_payload)
	print("LDAP User Federation Added: {}".format(ucs_ldap_url))

	# User federation mapper (LDAP) #
	payload_ldap_mapper = {
		"name": "uid",
		"parentId": ldap_component_id,
		"providerId": "user-attribute-ldap-mapper",
		"providerType": "org.keycloak.storage.ldap.mappers.LDAPStorageMapper",
		"config": {
			"ldap.attribute": [
				"uid"
			],
			"is.mandatory.in.ldap": [
				"false"
			],
			"read.only": [
				"true"
			],
			"user.model.attribute": [
				"uid"
			]
		}
	}

	# find existing uid->uid mapper or create if none exits #
	check_and_create_component(kc_admin, payload_ldap_mapper["name"], payload_ldap_mapper["providerId"], payload_ldap_mapper)

	# Setting admin level to all Domain Admins #
	# Change realm to master
	kc_admin.realm_name = default_realm

	# Admins federation ldap provider payload #
	ldap_federation_payload["name"] = "ldap-master-admin"
	ldap_federation_payload["parentId"] = get_realm_id(kc_admin, default_realm)
	ldap_federation_payload["config"]["customUserSearchFilter"] = ["(memberOf=cn=Domain Admins,cn=groups,{dn})".format(dn=user_dn)]

	# find existing ldap provider or just create if none exists #
	ldap_component_id = check_and_create_component(kc_admin, ldap_federation_payload["name"], ldap_federation_payload["providerId"], ldap_federation_payload)
	print("LDAP Domain Admins Federation Added: {}".format(ucs_ldap_url))
	print("Filter: {}".format(ldap_federation_payload["config"]["customUserSearchFilter"]))

	payload_ldap_mapper["name"] = "admin-role"
	payload_ldap_mapper["parentId"] = ldap_component_id
	payload_ldap_mapper["providerId"] = "hardcoded-ldap-role-mapper"
	payload_ldap_mapper["config"] = {"role": ["admin"]}

	# find existing mapper or create if none exits #
	check_and_create_component(kc_admin, payload_ldap_mapper["name"], payload_ldap_mapper["providerId"], payload_ldap_mapper)


def main():
	# type: () -> int
	"""
	CLI tool to interact with Keycloak.
	"""
	opt = parse_args()

	#try:
	return opt.func(opt) or 0
	#except Exception:
	#	return 1


if __name__ == "__main__":
	exit(main())
