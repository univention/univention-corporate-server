#!/usr/bin/python2.7
# -*- coding: utf-8 -*-
"""\
{prog}: Perform a (dist-)upgrade and (un-)install packages as set
                      through policies

usage: {prog} [-? || --help] [--dist-upgrade] [--silent] [--check]

-?, --help       Show this message
--dist-upgrade   Perform a dist-upgrade instead of a regular update
--silent         Don't show normal output, but error messages only
--check          Don't do anything, just check if updates are available
"""
# Copyright 2004-2021 Univention GmbH
#
# https://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <https://www.gnu.org/licenses/>.

# TODO: use UCR variables for update, upgrade, install and remove commands
from __future__ import print_function

import os
import sys
import time
import commands
import shlex
import subprocess
try:
    from typing import List  # noqa F401
except ImportError:
    pass

from univention.config_registry import ConfigRegistry, handler_set, handler_unset
from univention.updater.commands import (
    cmd_config,
    cmd_dist_upgrade,
    cmd_dist_upgrade_sim,
    cmd_install,
    cmd_remove,
    cmd_show,
    cmd_update,
    cmd_upgrade,
    cmd_upgrade_sim,
)
from univention.updater.locking import UpdaterLock, apt_lock
from univention.lib.policy_result import PolicyResultFailed, policy_result

LOGNAME = '/var/log/univention/actualise.log'

configRegistry = ConfigRegistry()
configRegistry.load()

ldap_hostdn = configRegistry.get('ldap/hostdn')


class Tee(object):

    '''
    Writes the given string to several files at once. Could by used
    with the print statement
    '''

    def __init__(self, files=[], stdout=True, filter=None):
        self.stdout = stdout
        self.files = files
        self.filter = filter

    def call(self, command, **kwargs):
        devnull = None
        p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, **kwargs)
        tee_command = ['tee', '-a'] + self.files
        if self.stdout:
            if self.filter:
                tee = subprocess.Popen(tee_command, stdin=p.stdout, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                egrep = subprocess.Popen(['egrep', self.filter], stdin=tee.stdout)
                ret = egrep.wait()
            else:
                tee = subprocess.Popen(tee_command, stdin=p.stdout)
        else:
            with open(os.path.devnull, 'a') as devnull:
                tee = subprocess.Popen(tee_command, stdin=p.stdout, stdout=devnull)

        # Must wait for exit from back to front, only the exit status of p is relevant
        ret = tee.wait()
        ret = p.wait()
        if devnull:
            devnull.close()

        return ret


def usage(fd=sys.stdout):
    """
    Print usage message.

    :param file fd: Override standard error output. Defaults to :py:obj:`sys.stdout`.
    """
    fd.write(__doc__.format(prog=os.path.basename(__file__)))


def getUpdate(configRegistry):
    # Small function waiting for apt lockfile to vanish then starts apt-get update

    print("Running apt-get update")
    with apt_lock(), open(LOGNAME, 'a') as logfile:
        res = subprocess.call(shlex.split(cmd_update), stdout=logfile, stderr=logfile)

    if res != 0:
        print("E: failed to update", file=sys.stderr)
        sys.exit(res)


def deactivateSourcesListMethods(methods=['cdrom']):
    cnt = 0
    lines = []
    deactivated_lines = []
    with open('/etc/apt/sources.list', 'r') as f:
        for line in f.readlines():
            line = line.strip(' \n\t')
            for method in methods:
                if line.startswith('deb %s:' % method) or line.startswith('deb-src %s:' % method):
                    line = '#%s' % line
                    deactivated_lines.append(line)
                    cnt += 1
            lines.append(line)

    if cnt:
        with open('/etc/apt/sources.list', 'w') as f:
            f.write('\n'.join(lines))
            f.write('\n')

        with open(LOGNAME, 'a+') as debug_file:
            debug_file.write('Hint: deactivated %d lines in /etc/apt/sources.list:\n' % cnt)
            debug_file.write('   %s\n' % '\n   '.join(deactivated_lines))


def check(configRegistry, dist_upgrade=False):
    # Just probe if there are packages to add or remove

    actualise = False
    getUpdate(configRegistry)

    # Probe for packages to actualise
    if dist_upgrade:
        cmd = cmd_dist_upgrade_sim
    else:
        cmd = cmd_upgrade_sim

    with apt_lock():
        res = commands.getoutput('%s | egrep ".*[0-9] upgraded, [0-9].*"' % (cmd))
    sres = res.split()

    # These ones are nicer to read
    upgraded = int(sres[0])
    newlyinstalled = int(sres[2])
    remove = int(sres[5])

    # If there are any packages to upgrade, install or remove
    if upgraded != 0 or newlyinstalled != 0 or remove != 0:
        actualise = True

    # Probe for policies
    rem_packages = getPackageList(configRegistry, 'remove')
    add_packages = getPackageList(configRegistry, 'add')

    return 1 if rem_packages or add_packages or actualise else 0


def getPackageList(configRegistry, job):
    # type: (ConfigRegistry, str) -> List[str]
    """
    Get a list of packages to remove or add, depending on the value of job.

    :param configRegistry: UCR instance.
    :param job: `add` or `remove`.
    :returns: List of package names.
    """
    try:
        packages_name = 'univention%sPackages%s' % (
            {
                "memberserver": "Member",
                "domaincontroller_slave": "Slave",
                "domaincontroller_master": "Master",
                "domaincontroller_backup": "Master",
            }[configRegistry['server/role']],
            {
                "remove": "Remove",
                "add": "",
            }[job],
        )
    except LookupError:
        exit("E: no valid job defined")

    try:
        results, policies = policy_result(ldap_hostdn)
        return results.get(packages_name, [])
    except PolicyResultFailed as ex:
        sys.exit('failed to execute univention_policy_result: %s' % ex)


def main():
    os.putenv('PATH', '/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11')
    os.environ['LC_ALL'] = 'C'

    pkgdb = None
    pkgdb_scope = None
    silent = False
    print_usage = False
    dist_upgrade = False
    check_only = False

    # parse arguments
    for arg in sys.argv[1:]:
        if arg == "--silent":
            silent = True
        elif arg == "-?" or arg == "--help":
            print_usage = True
        elif arg == "--dist-upgrade":
            dist_upgrade = True
        elif arg == '--check':
            check_only = True
        else:
            # unknown parameter
            print_usage = True

    if print_usage:
        usage()
        sys.exit(0)

    if silent:
        # redirect stdout to /dev/null
        sys.stdout = open("/dev/null", "w")

    try:
        if check_only:
            # Only probe for packages to add/remove
            return check(configRegistry, dist_upgrade)

        if ldap_hostdn:
            logfile = open(LOGNAME, 'a')
            logfile.write('***** Starting univention-actualise at %s\n' % time.ctime())

            deactivateSourcesListMethods(methods=['cdrom'])

            getUpdate(configRegistry)

            # temporarily disable pkgdb
            pkgdb_scan = configRegistry.get('pkgdb/scan', getscope=True)
            if pkgdb_scan:
                # get value and UCR scope of variable pkgdb/scan
                pkgdb_scope, pkgdb = pkgdb_scan
                if pkgdb:
                    # disable pkgdb in UCR scope FORCED
                    handler_set(['pkgdb/scan=no'], {'force': True})

            rem_packages = getPackageList(configRegistry, 'remove')
            for package in rem_packages:
                # check if the package exists
                with apt_lock():
                    res = subprocess.call(shlex.split(cmd_show) + [package], stdout=logfile, stderr=logfile)
                if res == 0:
                    print("Removing packages: %s" % package)
                    os.environ['DEBIAN_FRONTEND'] = 'noninteractive'
                    with apt_lock():
                        res = subprocess.call(shlex.split(cmd_config), stdout=logfile, stderr=logfile)
                    if not res:
                        res = subprocess.call(shlex.split(cmd_remove) + [package], stdout=logfile, stderr=logfile)
                else:
                    print("The package %s doesn't exist." % package)
                    res = 0
                if res != 0:
                    print("E: failed to remove %s" % package, file=sys.stderr)
                    sys.exit(res)

            add_packages = getPackageList(configRegistry, 'add')
            for package in add_packages:
                with apt_lock():
                    res = subprocess.call(shlex.split(cmd_show) + [package], stdout=logfile, stderr=logfile)
                if res == 0:
                    print("Installing packages: %s" % package)
                    os.environ['DEBIAN_FRONTEND'] = 'noninteractive'
                    with apt_lock():
                        res = subprocess.call(shlex.split(cmd_config), stdout=logfile, stderr=logfile)
                    if not res:
                        res = subprocess.call(shlex.split(cmd_install) + [package], stdout=logfile, stderr=logfile)
                else:
                    print("The package %s doesn't exist." % package)
                    res = 0

                if res != 0:
                    print("E: failed to install %s" % package, file=sys.stderr)
                    sys.exit(res)

        else:
            # ldap/hostdn is not set
            if configRegistry['server/role'] != 'basesystem':
                print("W: ldap/hostdn is not set - please run univention-join", file=sys.stderr)

        if dist_upgrade:
            msg = "Dist-upgrading system"
            cmd = cmd_dist_upgrade
        else:
            msg = "Upgrading system"
            cmd = cmd_upgrade

        print(msg)
        # TODO: use mkstemp and close directly the file descriptor

        os.environ['DEBIAN_FRONTEND'] = 'noninteractive'
        with apt_lock():
            tee = Tee([LOGNAME], stdout=not silent)
            res = tee.call(shlex.split(cmd_config))
        if res != 0:
            print("E: failed to configure packets, see %s for details." % LOGNAME, file=sys.stderr)
        else:
            tee = Tee([LOGNAME], stdout=not silent, filter='(^Get|^Unpacking|^Preparing|^Setting up|packages upgraded)')
            res = tee.call(cmd.split(' '))
            if res != 0:
                print("E: failed to upgrade, see %s for details." % LOGNAME, file=sys.stderr)

        sys.exit(res)

    finally:
        if pkgdb:
            if pkgdb_scope == ConfigRegistry.FORCED:
                # old value was set in FORCED scope
                handler_set(['pkgdb/scan=%s' % pkgdb], {'force': True})
            else:
                # old value was set in any other scope ==> remove value in FORCED scope
                handler_unset(['pkgdb/scan'], {'force': True})

            if str(pkgdb).lower() in ("yes", "enable", "enabled", "true", "1"):
                if not silent:
                    os.system('/usr/sbin/univention-pkgdb-scan')
                else:
                    os.system('/usr/sbin/univention-pkgdb-scan > /dev/null')


def update_ucr_updatestatus():
    try:
        with open(os.path.devnull, 'w') as devnull:
            subprocess.call('/usr/share/univention-updater/univention-updater-check', stdout=devnull, stderr=devnull)
    except Exception:
        print('Warning: calling univention-updater-check failed.')


if __name__ == '__main__':
    res = 0
    try:
        with UpdaterLock():
            failure = '/var/lib/univention-updater/update-failed'
            if os.path.exists(failure):
                print('univention-actualise: univention-updater failed, stopping...')
                print('	   remove `%s\' to proceed' % failure)
                sys.exit(2)

            try:
                for root, dirs, files in os.walk('/etc/apt/sources.list.d'):
                    for file in [file for file in files if file.startswith('00_ucs_temporary_')]:
                        filename = os.path.join(root, file)
                        print('Warning: Deleting `%s` from incomplete update.' % filename)
                        os.remove(filename)
                    del dirs[:]
            except:
                print('Failed, aborting.')
                sys.exit(2)

            res = main()
    except SystemExit as ex:
        if ex.args[0] == 0:
            update_ucr_updatestatus()
    sys.exit(res)
