#!/usr/bin/python2.4
#
# Univention Updater
#  A tool for installing UCS release updates
#
# Copyright (C) 2004-2009 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# Binary versions of this file provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

# The following commands are supported:
#  * local
#  * cdrom
#  * net

import os, sys, time, re
import string
import getopt
import tempfile
import shutil
import subprocess

import univention_baseconfig

from univention.updater import UniventionUpdater, UCS_Version

# TODO:
#   * check the local repository path /var/lib/univention-reposiotry
#   * changed variable update/server to repository/online/server

failure = '/var/lib/univention-updater/update-failed'
reboot_required = '/var/lib/univention-updater/reboot-required'

class UpdateError(Exception):
	pass

class UpToDateNoError(Exception):
	def __init__(self, value=None):
		Exception.__init__(self, value)
		self.reboot = value

def dprint(str, fd=[]):
	if len(fd) < 1:
		print str
		sys.stdout.flush()
	for i in range(0,len(fd)):
		print >>fd[i], str
		fd[i].flush()

def usage(fd=sys.stdout):
	print >>fd, 'univention-updater: tool for updating local system'
	print >>fd, 'copyright (c) 2005-@%@copyright_lastyear@%@ Univention GmbH, Germany'
	print >>fd, ''
	print >>fd, 'Syntax:'
	print >>fd, '  univention-updater <local,net,cdrom> [--device <cdrom device>] [--cdrom <cdrom mount point>] [--iso <iso-image>] [--updateto <UCS-Release>] [--reboot <timespec>] [--no-clean] [--check] '
	print >>fd, '  univention-updater [--help] '
	print >>fd, ''
	print >>fd, 'Known-Bugs:'
	print >>fd, '  -None-'
	print >>fd, ''

def deactivateSourcesListMethods( methods = [ 'cdrom' ] ):
	cnt = 0
	lines = []
	deactivated_lines = []
	f = open('/etc/apt/sources.list', 'r')
	for line in f.readlines():
		line=line.strip(' \n\t')
		for method in methods:
			if line.startswith( 'deb %s:' % method ) or line.startswith( 'deb-src %s:' % method ):
				line = '#%s' % line
				deactivated_lines.append(line)
				cnt += 1
		lines.append(line)
	f.close()
	if cnt:
		f = open('/etc/apt/sources.list', 'w')
		f.write( '\n'.join( lines ) )
		f.write( '\n' )
		f.close()
		dprint('Hint: deactivated %d lines in /etc/apt/sources.list:\n' % cnt)
		dprint( '   %s\n' % '\n   '.join(deactivated_lines) )

def add_temporary_sources_list ( debline ):
	filename = '/etc/apt/sources.list.d/00_ucs_temporary_installation.list'
	fp = open(filename, 'a+')
	fp.write(debline+'\n')
	fp.close()

def remove_temporary_sources_list ():
	filename = '/etc/apt/sources.list.d/00_ucs_temporary_installation.list'
	if os.path.exists(filename):
		os.remove(filename)


def copy_sh_files(tempdir,path):
	for sh in ['preup.sh', 'postup.sh']:
		if os.path.exists(os.path.join(tempdir,sh)):
			os.remove(os.path.join(tempdir,sh))
		if os.path.exists(os.path.join(path,sh)):
			shutil.copy(os.path.join(path,sh), os.path.join(tempdir,sh))
			os.chmod(os.path.join(tempdir, sh), 0744)

def download_sh_files(updater, server_path, tempdir):
	for sh in ['preup.sh', 'postup.sh']:
		if os.path.exists(os.path.join(tempdir,sh)):
			os.remove(os.path.join(tempdir,sh))

		proxy_headers = updater.open_connection()
		path="%s/%s" % ( server_path, sh )
		site = '%s/%s/%s' % (updater.proxy_prefix, updater.repository_prefix, path)
		replace_slash = re.compile ('[/]{2,}')
		site = replace_slash.sub ('/', site)
		if not site.startswith ('http://') and proxy_headers:
			site = 'http://%s' % site
		if proxy_headers:
			updater.connection.putrequest('GET', site, skip_host=1, skip_accept_encoding=1)
		else:
			updater.connection.putrequest('GET', site)

		if proxy_headers:
			for k, v in proxy_headers.items ():
				updater.connection.putheader (k, v)
		try:
			updater.connection.endheaders ()
			response = updater.connection.getresponse()
			response_data = response.read()

			if response.status != 200:
				dprint('failed to download %s' % path)
				dprint(' %s: %s' % (response.status,response.reason))
				continue
		except:
			import traceback
			dprint( traceback.format_exc ())

		f=open(os.path.join(tempdir, sh), 'w+' )
		f.write(response_data)
		f.close()
		os.chmod(os.path.join(tempdir, sh), 0744)

		updater.close_connection()


def update_available(mode, baseConfig, cdrom_mount_point, sourcedir, stdout, sys_stdout, reboot, internal=1, iso=None, updater=None):
	# Checks if there is an update available

	dprint('--->DBG:update_available(mode=%s, cdrom_mount_point=%s, reboot=%s, internal=%s, iso=%s)' %(mode, cdrom_mount_point, str(reboot), str(internal), str(iso)))

	update=0
	nextversion = None

	vv=baseConfig['version/version']
	vp=baseConfig['version/patchlevel']
	version_major = vv.split('.')[0]
	version_minor = vv.split('.')[-1]

	if mode == 'local':

		print 'Checking local repository'

		repository_path = baseConfig.get( 'repository/mirror/basepath', '/var/lib/univention-repository')

		if os.path.exists( repository_path ):
			repo_base = '%s/mirror/' % repository_path
			if os.path.exists( os.path.join( repo_base, vv, 'maintained', '%s-%d' % ( vv, int( vp ) + 1 ) ) ): #check for x.y-(z+1)
				nextversion = '%s-%d' % (vv, int(vp)+1)
			elif os.path.exists(os.path.join( repo_base, vv, 'maintained', '%s.%d-0' % ( version_major, int( version_minor ) + 1 ) ) ): #check for x.(y+1)-0
				nextversion = '%s.%d-0' % (version_major, int(version_minor)+1)
			elif os.path.exists(os.path.join( repo_base, vv, 'maintained', '%d.0-0' % ( int( version_major ) + 1 ) ) ): #check for (x+1).0-0
				nextversion = '%d.0-0' % (int(version_major)+1)

			if not nextversion:
				update=0
				dprint('System is up to date (UCS %s-%s)' % (vv,vp), [stdout,sys_stdout])
				if internal:
					sys_stdout.close()
					raise UpToDateNoError(reboot)
			else:
				dprint('Next version is %s' % nextversion, [stdout,sys_stdout])
				update=1

		else:
			dprint('Error: A local repository was not found.', [stdout,sys_stdout])
			dprint('       Please check the UCR variable repository/mirror/basepath', [stdout,sys_stdout])
			dprint('       or try to install via "univention-updater net"', [stdout,sys_stdout])
			update=0
			if internal:
				sys_stdout.close()
				raise UpToDateNoError(reboot)

	elif mode == 'cdrom':
		if iso:
			device_name="ISO image"

			dprint('Mounting the ISO image %s' % iso, [stdout,sys_stdout])

			resultCode=os.system('mount -o loop %s %s' % ( iso, cdrom_mount_point))
			if resultCode != 0:
				res=os.system('mount -l | grep " %s " >>/var/log/univention/updater.log 2>&1' % (cdrom_mount_point))
				if res != 0:
					dprint('Failed to mount %s' % iso, [stdout,sys_stdout])
					update=0
					if internal:
						sys_stdout.close()
						raise UpdateError
		else:
			device_name="cdrom"

			dprint('Mounting cdrom %s' % cdrom_mount_point, [stdout,sys_stdout])

			resultCode=os.system('mount %s' % ( cdrom_mount_point))
			if resultCode != 0:
				res=os.system('mount -l | grep " %s " >>/var/log/univention/updater.log 2>&1' % (cdrom_mount_point))
				if res != 0:
					dprint('Failed to mount cdrom', [stdout,sys_stdout])
					update=0
					if internal:
						sys_stdout.close()
						raise UpdateError

		# Let's check if this Update could be installed, as on the dvd is a textfile for which UCS release this update is
		if os.path.exists('%s/ucs-updates/' % cdrom_mount_point):
			if os.path.exists('%s/ucs-updates/ucs_%s-%s.txt' % (cdrom_mount_point,vv,vp)):
				f=open('%s/ucs-updates/ucs_%s-%s.txt' % (cdrom_mount_point,vv,vp))
				nextversion=string.lower(f.readline().strip('\n').replace('nextupdate=',''))
				f.close()
				if nextversion == 'none':
					update=0
					dprint('System is up to date (UCS %s-%s)' % (vv,vp), [stdout,sys_stdout])
					# No raise because we need to return none
				else:
					dprint('Next version is %s' % nextversion, [stdout,sys_stdout])
					update=1
			else:
				update=0
				dprint("%s does not contain an update for version %s-%s."%(device_name,vv,vp), [stdout,sys_stdout])
				if internal:
					sys_stdout.close()
					raise UpdateError
		else:
			update=0
			dprint("%s is not a valid UCS update medium" % device_name, [stdout,sys_stdout])
			if internal:
				sys_stdout.close()
				raise UpdateError

		resultCode=os.system('umount %s' % ( cdrom_mount_point))
		if resultCode != 0:
			res=os.system('umount -l | grep " %s " >>/var/log/univention/updater.log 2>&1' % (cdrom_mount_point))
			if res != 0:
				dprint('Failed to unmount %s' % device_name, [stdout,sys_stdout])


	elif mode == 'net':
		updater = UniventionUpdater()

		nextversion = updater.release_update_available()

		dprint('Nextupdate: [%s]' % nextversion)

		if not nextversion:
			dprint('System is up to date (UCS %s-%s)' % (vv,vp), [stdout,sys_stdout])
			sys_stdout.close()
			raise UpToDateNoError(reboot)

	return nextversion



def main():
	os.putenv('PATH', '/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11')

	cdrom_device='/dev/cdrom'
	cdrom_mount_point='/cdrom'
	iso=None

	fp_debug=open('/var/log/univention/updater.log', 'a+')
	stdout=sys.stdout
	sys.stdout=fp_debug

	dprint('**** Starting univention-updater with parameter=%s' % sys.argv)

	if len(sys.argv) < 2:
		usage(stdout)
		fp_debug.close()
		sys.exit(2)

	if sys.argv[1] in ['-h', '-?', '--help']:
		usage(stdout)
		fp_debug.close()
		sys.exit(0)

	if sys.argv[1] == 'net':
		command='net'
	elif sys.argv[1] == 'cdrom':
		command='cdrom'
	elif sys.argv[1] == 'local':
		command='local'
	else:
		usage(stdout)
		fp_debug.close()
		sys.exit(2)

	updateto=None
	updateto_args = []
	reboot = None
	clean  = True

	longopts=['src=','device=', 'cdrom=', 'iso=', 'updateto=', 'reboot=', 'no-clean', 'check']
	try:
		opts, args=getopt.getopt(sys.argv[2:], '', longopts)
	except getopt.error, msg:
		dprint(msg, [stdout,sys.stdout])
		fp_debug.close()
		sys.exit(2)

	import univention_baseconfig
	baseConfig=univention_baseconfig.baseConfig()
	baseConfig.load()
	sourcedir=None
	for opt, val in opts:
		if opt == '--src':
			sourcedir=val
		elif opt == "--device":
			cdrom_device=val
		elif opt == "--cdrom":
			cdrom_mount_point=val
		elif opt == "--iso":
			iso=val
		elif opt == "--updateto":
			updateto=val
		elif opt == '--reboot':
			if val:
				reboot = val
			else:
				reboot = 'now'
		elif opt == "--no-clean":
			clean = False
			dprint("Running updater without apt-get clean", [stdout,sys.stdout])
		elif opt == '--check':
			update_available(command, baseConfig, cdrom_mount_point,sourcedir, stdout, sys.stdout, reboot, 0, iso=iso)
			sys.exit(0)
		else:
			dprint('Unknown Parameter: "%s"'%opt, [stdout,sys.stdout])
			fp_debug.close()
			sys.exit(2)

	deactivateSourcesListMethods( methods = [ 'cdrom' ] )

	# save the path for the pre- and postup scripts,
	# this path will be diffrent for the diffrent modes
	scriptPath = None

	if clean:
		os.system('apt-get clean')

	vv=baseConfig['version/version']
	vp=baseConfig['version/patchlevel']

	if updateto:
		actual='%s-%s' % (vv,vp)
		if actual == updateto:
			dprint('System is up to date (UCS %s-%s)' % (vv,vp), [stdout,sys.stdout])
			fp_debug.close()
			raise UpToDateNoError(reboot)
		updateto_args = [ '--updateto', updateto ]

	dprint('Version=%s' % vv)
	dprint('Patchlevel=%s' % vp)

	tempdir=tempfile.mktemp()
	os.mkdir(tempdir)

	dprint('using tempdir = %s' % tempdir)

	architecture=os.popen('dpkg-architecture -qDEB_BUILD_ARCH 2>/dev/null').readline()[:-1]

	if command == 'local':
		dprint('starting local mode')

		nextversion=update_available('local', baseConfig, cdrom_mount_point,sourcedir, stdout, sys.stdout, reboot, iso=iso)

		dprint('Update to = %s' % nextversion, [stdout, sys.stdout])

		repository_path = baseConfig.get( 'repository/mirror/basepath', '/var/lib/univention-repository')

		remove_temporary_sources_list()
		new_version = UCS_Version( nextversion )
		for arch in ['all', architecture, 'extern']:
			if os.path.exists('%s/mirror/%d.%d/maintained/%s/%s' % ( repository_path, new_version.major, new_version.minor, nextversion, arch ) ):
				add_temporary_sources_list ( 'deb file:%s/mirror/%d.%d/maintained/ %s/%s/' % ( repository_path, new_version.major, new_version.minor, nextversion, arch ) )
		scriptPath = '%s/%s/%s' % (repository_path, nextversion, arch)

	elif command == 'cdrom':
		dprint('starting cdrom mode')
		if iso:
			device_name="ISO image"
		else:
			device_name="cdrom"

		nextversion=update_available('cdrom', baseConfig, cdrom_mount_point,sourcedir, stdout, sys.stdout, reboot, iso=iso)

		if not nextversion:
			dprint('System is up to date (UCS %s-%s)' % (vv,vp), [stdout,sys.stdout])
			fp_debug.close()
			raise UpToDateNoError(reboot)

		dprint('Update to = %s' % nextversion, [stdout,sys.stdout])

		if baseConfig.has_key('local/repository') and ( baseConfig['local/repository'] == 'true' or baseConfig['local/repository'] == 'yes'):
			dprint('local/reposity active, copy %s and start local mode' % device_name)
			if iso:
				resultCode = subprocess.call( [ '/usr/sbin/univention-repository-update cdrom', '--cdrom', cdrom_mount_point, '--iso', iso ] + updateto_args )
			else:
				resultCode = subprocess.call( [ '/usr/sbin/univention-repository-update cdrom', '--cdrom', cdrom_mount_point ] + updateto_args )

			if resultCode != 0:
				dprint('Failed to execute univention-repository-update cdrom', [sys.stdout,stdout])
				raise UpdateError

			callupdateto=[sys.argv[0], 'local', '--updateto', updateto]
			calllocal=[sys.argv[0], 'local']

			if not clean:
				callupdateto.append('--no-clean')
				calllocal.append('--no-clean')

			if updateto:
				os.execv(sys.argv[0], callupdateto)
			else:
				os.execv(sys.argv[0], calllocal)
		else:
			dprint('Error: You are trying to install from a cdrom/dvd image', [stdout,sys.stdout])
			dprint('       but a local repository was not found. If you want to' [stdout,sys.stdout])
			dprint('       update via an image you need to create a local' [stdout,sys.stdout])
			dprint('       repository (usr/sbin/univention-repository-create)' [stdout,sys.stdout])
			dprint('       or try to install via "univention-updater net"' [stdout,sys.stdout])
			pass

	elif command == 'net':
		dprint('starting net mode')
		list=[]
		if baseConfig.has_key('local/repository') and ( baseConfig['local/repository'] == 'true' or baseConfig['local/repository'] == 'yes'):
			dprint('local/repository active, copy from net and start local mode')
			resultCode = subprocess.call( [ '/usr/sbin/univention-repository-update', 'net' ] + updateto_args )
			if resultCode != 0:
				dprint('Failed to execute univention-repository-update net', [sys.stdout,stdout])
				raise UpdateError

			callupdateto=[sys.argv[0], 'local', '--updateto', updateto]
			calllocal=[sys.argv[0], 'local']

			if not clean:
				callupdateto.append('--no-clean')
				calllocal.append('--no-clean')

			if updateto:
				os.execv(sys.argv[0], callupdateto)
			else:
				os.execv(sys.argv[0], calllocal)

		updater = UniventionUpdater()

		nextversion=update_available('net', baseConfig, cdrom_mount_point,sourcedir, stdout, sys.stdout, reboot, iso=iso, updater=updater)

		dprint('Update to = %s' % nextversion, [stdout, sys.stdout])


		next_vv = nextversion.split('-')[0]
		next_vp = nextversion.split('-')[-1]

		remove_temporary_sources_list()
		for arch in ['all', architecture, 'extern' ]:
			if updater.net_path_exists('%s/maintained/%s-%s/%s/' % (next_vv, next_vv, next_vp, arch)):
				if updater.repository_prefix:
					add_temporary_sources_list ('deb http://%s/%s/%s/maintained/ %s/%s/' % ( updater.repository_server, updater.repository_prefix, next_vv, nextversion, arch))
				else:
					add_temporary_sources_list ('deb http://%s/%s/maintained/ %s/%s/' % ( updater.repository_server, next_vv, nextversion, arch))

		# Download the pre and postup scripts
		scriptPath = tempdir
		download_sh_files(updater, '%s/%s/maintained/%s-%s/all' % (updater.repository_prefix, next_vv, next_vv, next_vp), tempdir)

	# Call the preup.sh
	if scriptPath:
		dprint('Call the preup.sh file with the path: %s' % scriptPath)
		if os.path.exists(os.path.join(scriptPath, 'preup.sh')):
			dprint('Execute %s' % os.path.join(scriptPath, 'preup.sh'))
			os.chmod(os.path.join(scriptPath, 'preup.sh'), 0744)
			resultCode=os.system('%s | tee -a /var/log/univention/updater.log 2>&1' % os.path.join(scriptPath, 'preup.sh'))
			if resultCode != 0:
				dprint('Failed to execute preup.sh', [sys.stdout,stdout])
				raise UpdateError

	count=0
	while os.path.exists('/var/run/apt-get.lock') and count < 300:
		time.sleep(1)
		count=count+1

	# TODO: should we really exit if the 'apt-get update' process failed?
	resultCode=os.system('touch /var/run/apt-get.lock && apt-get update >>/var/log/univention/updater.log 2>&1')
	if os.path.exists('/var/run/apt-get.lock'):
		os.unlink('/var/run/apt-get.lock')
	if resultCode != 0:
		dprint('Failed to execute apt-get update', [sys.stdout,stdout])
		raise UpdateError

	# Execute the dist-upgrade!
	count=0
	while os.path.exists('/var/run/apt-get.lock') and count < 300:
		time.sleep(1)
		count=count+1
	resultCode=os.system('touch /var/run/apt-get.lock && DEBIAN_FRONTEND=noninteractive apt-get -o DPkg::Options::=--force-confold -y --force-yes -u dist-upgrade >>/var/log/univention/updater.log 2>&1')
	if os.path.exists('/var/run/apt-get.lock'):
		os.unlink('/var/run/apt-get.lock')
	if resultCode != 0:
		dprint('Failed to execute apt-get -u dist-upgrade', [sys.stdout,stdout])
		raise UpdateError

	# Call the postup.sh
	if scriptPath:
		dprint('Call the postup.sh file with the path: %s' % scriptPath)
		if os.path.exists(os.path.join(scriptPath, 'postup.sh')):
			dprint('Execute %s' % os.path.join(scriptPath, 'postup.sh'))
			os.chmod(os.path.join(scriptPath, 'postup.sh'), 0744)
			resultCode=os.system('%s | tee -a /var/log/univention/updater.log 2>&1' % os.path.join(scriptPath, 'postup.sh'))
			if resultCode != 0:
				dprint('Failed to execute postup.sh', [sys.stdout,stdout])
				raise UpdateError

	nvv=nextversion.split('-')[0]
	nvp=nextversion.split('-')[1]

	import univention_baseconfig
	out=univention_baseconfig.handler_set(['version/version=%s' % nvv, 'version/patchlevel=%s' % nvp])

	if os.path.exists('/usr/sbin/univention-pkgdb-scan'):
		os.system('/usr/sbin/univention-pkgdb-scan >>/var/log/univention/updater.log 2>&1')

	fp_debug.close()
	if os.path.exists(failure):
		os.unlink(failure)
	os.system('touch %s' % reboot_required)
	os.execv(sys.argv[0], sys.argv)

if __name__ == '__main__':
	try:
		main()
	except UpdateError:
		os.system('touch %s' % failure)
		sys.exit(1)
	except UpToDateNoError, error:
		if os.path.exists(failure):
			os.unlink(failure)
		if os.path.exists(reboot_required):
			os.unlink(reboot_required)
			if error.reboot is not None:
				os.system('at -f /var/lib/univention-updater/reboot.at -- %s' % error.reboot)
		sys.exit(0)
