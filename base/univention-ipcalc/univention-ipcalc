#!/usr/bin/python2.6
#
# Univention IP Calculator
#  helper script: base on IP adress and network mask the script
#  calculates brodcast address, network address and DNS entries
#
# Copyright 2004-2012 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

import string, os, sys, getopt, copy


longopts=['ip=', 'netmask=', 'quiet', 'output=', 'full', 'calcdns']

full=0
ip=None
netmask=None
quiet=None
calcdns=0
output='all'


try:
	opts, args=getopt.getopt(sys.argv[1:], '', longopts)
except getopt.error, msg:
	print msg
	sys.exit(1)

for opt, val in opts:
	if opt == '--ip':
		ip=val
	elif opt == '--netmask':
		netmask=val
	elif opt == '--quiet':
		quiet='1'
	elif opt == '--output':
		output=val
	elif opt == '--full':
		full=1
	elif opt == '--calcdns':
		calcdns=1

if not ip or not netmask:
	if not quiet:
		print "Needed --ip and --netmask"
	sys.exit(1)

ip_list=ip.split('.')
netmask_list=netmask.split('.')

if len(ip_list) != 4:
	if not quiet:
		print 'Invalid ip'
	sys.exit(1)
if len(netmask_list) != 4:
	if not quiet:
		print 'Invalid netmask'
	sys.exit(1)

net=[]
reverse=[]
wildcard=[]
pointerok=0
broadcast=[]

if not calcdns:
	for i in range(4):
		if netmask_list[i] == '255':
			net.append(ip_list[i])
			wildcard.append(0)
			broadcast.append(ip_list[i])
			if i == 3:
				pointer=ip_list[3:]
				pointerok=1
		else:
			net.append(str(int(ip_list[i]) & int(netmask_list[i])))
			if not pointerok:
				pointer=ip_list[i:]
				pointerok=1
			pointer.reverse()
			calc = 255 - int(netmask_list[i])
			if not calc:
				wildcard.append(0)
			wildcard.append(calc)
			calc = int(wildcard[i]) ^ int(net[i])
			if calc == '0' and i == '4':
				broadcast.append(str('255'))
			else:
				broadcast.append(str(calc))
else:
	for i in range(4):
		#TODO: check for other values
		if netmask_list[i] == '255':
			net.append(ip_list[i])
			if i == 3:
				pointer=ip_list[3:]
				pointerok=1
		else:
			pointer=ip_list[i:]
			pointer.reverse()
			break
	broadcast=copy.copy(net)
	while len(broadcast) < 4:
		broadcast.append('255')

reverse = net
if netmask == "255.255.255.255":
	reverse = net[:-1]

if output == 'all':
	print 'Network: %s' % string.join(net,'.')
	net.reverse()
	print 'Reverse: %s' % string.join(reverse,'.')
	print 'Pointer: %s' % string.join(pointer,'.')
	net.reverse()
	if full:
		netpart=copy.copy(netpart)
		while len(netpart) < 4:
			netpart.append('0')
		print 'Network full: %s' % string.join(netpart,'.')
	print 'Broadcast: %s' % string.join(broadcast,'.')
elif output == 'network':
	if full:
		while len(net) < 4:
			net.append('0')
		print '%s' % string.join(net,'.')
	else:
		print '%s' % string.join(net,'.')
elif output == 'reverse':
	print '%s' % string.join(reverse,'.')
elif output == 'pointer':
	print '%s' % string.join(pointer,'.')
elif output == 'broadcast':
	while len(net) < 4:
		net.append('255')
	print '%s' % string.join(broadcast,'.')
