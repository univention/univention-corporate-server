From: Jan Beulich <jbeulich@suse.com>
Date: Wed, 27 Nov 2013 09:50:43 +0100
Subject: CVE-2013-4553 x86: restrict XEN_DOMCTL_getmemlist

Coverity ID 1055652

(See the code comment.)

This is CVE-2013-4553 / XSA-74.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Tim Deegan <tim@xen.org>
master commit: 19f027cc5daff4a37fd0a28bca2514c721852dd0
master date: 2013-11-27 09:00:41 +0100
Commit-4.1: 8b596d92dbe8504c9c8284c451f3442d8e301af9
---
 xen/arch/x86/domctl.c | 20 ++++++++++++++++++++
 1 file changed, 20 insertions(+)

diff --git a/xen/arch/x86/domctl.c b/xen/arch/x86/domctl.c
index b70d7ca..831d920 100644
--- a/xen/arch/x86/domctl.c
+++ b/xen/arch/x86/domctl.c
@@ -383,6 +383,26 @@ long arch_do_domctl(
                 break;
             }
 
+            /*
+             * XSA-74: This sub-hypercall is broken in several ways:
+             * - lock order inversion (p2m locks inside page_alloc_lock)
+             * - no preemption on huge max_pfns input
+             * - not (re-)checking d->is_dying with page_alloc_lock held
+             * - not honoring start_pfn input (which libxc also doesn't set)
+             * Additionally it is rather useless, as the result is stale by
+             * the time the caller gets to look at it.
+             * As it only has a single, non-production consumer (xen-mceinj),
+             * rather than trying to fix it we restrict it for the time being.
+             */
+            if ( /* No nested locks inside copy_to_guest_offset(). */
+                 paging_mode_external(current->domain) ||
+                 /* Arbitrary limit capping processing time. */
+                 max_pfns > GB(4) / PAGE_SIZE )
+            {
+                ret = -EOPNOTSUPP;
+                break;
+            }
+
             spin_lock(&d->page_alloc_lock);
 
             if ( unlikely(d->is_dying) ) {
