#!/usr/bin/python3
# -*- coding: utf-8 -*-
#
# Univention Nagios
#
# Copyright 2004-2021 Univention GmbH
#
# https://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <https://www.gnu.org/licenses/>.

import enum
import os
import sys
import traceback
import subprocess
import argparse
import json
import fcntl

from datetime import datetime


__version__ = '1.2'


HELP = '''
Nagios check for the replication status of UCS backup/replica directory nodes.

This check will report CRITICAL if:
 * Replication has failed (failed.ldif exists) OR
 * The univention-directory-listener txid is behind that of the primary AND
 * The txid has not changed since the last invocation falling between -m and -M

This check will report WARNING if:
 * No invocation history is present OR
 * The txid is FAR (>= -w) behind the primary's, but is progressing

The following cases will report OK:
 * The listener is in sync with the primary's notifier
 * The listener's txid is behind (< -w) the primary's, but is progressing
'''


class NagiosStatus(enum.Enum):
	OK = 0
	WARNING = 1
	CRITICAL = 2
	UNKNOWN = 3

	def __call__(self, msg='', *args, nid=None, lid=None):
		print(msg.format(*args), end='')
		if nid is not None and lid is not None:
			print(" | offset={} 'notifier id'={} 'listener id'={}".format(nid - lid, nid, lid), end='')
		print()
		sys.exit(self.value)


class Parser(argparse.ArgumentParser):
	'''
	Nagios Check compliant command line parser:
	Exit with code 3 (unknown) instead of 1 (critical)
	'''

	def error(self, message):
		NagiosStatus.UNKNOWN('{}: error: {}', self.prog, message)


class ReplicationCheck:

	def __init__(self):
		self.FAILED_LDIF_FN = '/var/lib/univention-directory-replication/failed.ldif'
		self.PROG_GETNOTIFIERID = '/usr/share/univention-directory-listener/get_notifier_id.py'
		self.PROG_GETLISTENERID = 'cat /var/lib/univention-directory-listener/notifier_id'
		self.history = []
		self.parse_args()
		self.now = int(datetime.utcnow().timestamp())

	def vprint(self, *args, **kwargs):
		if self.verbose:
			print(*args, **kwargs)

	def load_history(self, histfile):
		histfile.seek(0)
		try:
			self.history = json.load(histfile)
			# Prune old entries from history
			self.history = [x for x in self.history if self.now - x[2] < self.max_age]
			self.vprint('History loaded:', self.history)
		except BaseException:
			self.vprint('Loading history failed!')

	def save_history(self, histfile):
		histfile.seek(0)
		histfile.truncate()
		json.dump(self.history, histfile)
		self.vprint('History saved:', self.history)

	def parse_args(self):
		parser = Parser(formatter_class=argparse.RawDescriptionHelpFormatter, description=HELP)
		parser.add_argument('--version', action='version', version=__version__)
		parser.add_argument('-v', '--verbose', action='store_true', help='Verbose debug output')
		parser.add_argument('-r', '--readonly', action='store_true', help='Do not modify the history file')
		parser.add_argument('-w', '--warning',
			type=int, metavar='cnt', dest='diff_warning', default=100,
			help='WARNING if difference of transaction IDs is >= <cnt>')
		parser.add_argument('-M', '--max-age',
			type=int, metavar='seconds', dest='max_age', default=900,
			help='Disregard and remove all history entries older than <seconds>')
		parser.add_argument('-m', '--min-age',
			type=int, metavar='seconds', dest='min_age', default=300,
			help='Disregard all history entries younger than <seconds>')
		parser.add_argument('-f', '--hist-file', '--history-file',
			type=str, metavar='file', dest='histfn',
			default='/var/lib/univention-nagios/adfinis_check_univention_replication.cache',
			help='Path to the history file')
		ns = parser.parse_args()

		self.histfn = ns.histfn
		self.diff_warning = ns.diff_warning
		self.min_age = ns.min_age
		self.max_age = ns.max_age
		self.verbose = ns.verbose
		self.readonly = ns.readonly
		self.vprint('Options: histfn={}, diff_warning={}, max_age={}, min_age={}, readonly={}'.format(
			self.histfn, self.diff_warning, self.max_age, self.min_age, self.readonly))

	def main(self):

		# get transaction ids
		status, output = subprocess.getstatusoutput(self.PROG_GETNOTIFIERID)
		if status:
			NagiosStatus.WARNING('Cannot fetch notifier id. Is the notifier on the master node running? {}', output)
		try:
			notifier_id = int(output)
			listener_id = int(subprocess.getoutput(self.PROG_GETLISTENERID))
		except BaseException as e:
			NagiosStatus.WARNING('Cannot fetch replication transaction ids: {}', e)

		# Update the history file while keeping a lock on the history file
		with open(self.histfn, 'a+') as histfile:
			fcntl.flock(histfile, fcntl.LOCK_EX | fcntl.LOCK_NB)
			# The file is opened with the fp at the end of they file.  If the fp is at position 0,
			# the file was either empty or didn't exist before
			if histfile.tell() > 0:
				self.load_history(histfile)
			else:
				self.vprint('History does not exist yet')
				self.history.insert(0, (notifier_id, listener_id, self.now))
			if not self.readonly:
				self.save_history(histfile)
			fcntl.flock(histfile, fcntl.LOCK_UN)

		# CRITICAL if failed.ldif exists
		if os.path.exists(self.FAILED_LDIF_FN):
			NagiosStatus.CRITICAL('failed.ldif exists', nid=notifier_id, lid=listener_id)

		# OK, Replication is up to date
		if notifier_id == listener_id:
			NagiosStatus.OK('replication complete', nid=notifier_id, lid=listener_id)

		# WARNING if no previous history is found - can't check, but doesn't require intervention
		if len(self.history) == 0:
			NagiosStatus.WARNING('Check history is empty', nid=notifier_id, lid=listener_id)

		# diff stays None iff the latest considered history entry is marked as in sync
		diff = None
		for nid, lid, ts in self.history[1:]:
			# Disregard entries younger than min_age to cover manual check executions
			if self.now - ts < self.min_age:
				continue
			# Only look at history entries since the last full sync
			if nid == lid:
				break
			diff = diff or listener_id - lid > 0
			if diff:
				break
		self.vprint('diff: {}'.format(diff))

		# if change just occurred (None) or is progressing (True):
		# Issue a WARNING if replication is too far behind, otherwise say OK
		if diff is None or diff is True:
			if notifier_id - listener_id >= self.diff_warning:
				NagiosStatus.WARNING('Replication in progress, large backlog ({} transactions to go)',
					notifier_id - listener_id, nid=notifier_id, lid=listener_id)
			NagiosStatus.OK('Replication in progress ({} transactions to go)',
				notifier_id - listener_id, nid=notifier_id, lid=listener_id)

		# If none of the condiditions above match
		NagiosStatus.CRITICAL('Replication has been stalled for at least {} s',
			self.now - ts, nid=notifier_id, lid=listener_id)


if __name__ == '__main__':
	try:
		ReplicationCheck().main()
	except SystemExit as e:
		raise e
	except:
		# Print exception, but exit with nagios-compliant exit code
		traceback.format_exc()
		NagiosStatus.UNKNOWN(str(e))
