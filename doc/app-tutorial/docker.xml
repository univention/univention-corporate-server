<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE chapter [
	<!ENTITY % extensions SYSTEM "../stylesheets/macros.ent" >
	<!ENTITY % DocBookDTD PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
	"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
	<!ENTITY % entities SYSTEM "../stylesheets/macros-en.ent" >
	%extensions;
	%DocBookDTD;
	%entities;
]>
<chapter id="docker">
	<title>Docker Apps for the Univention App Center</title>
	<para>
		Starting with UCS 4.1 the Univention App Center will support Docker. Docker is an OS level virtualization software that helps
		deploying applications in isolated containers. In this chapter we will discuss the reasoning and aim of the Docker support, give
		some technical insights and also go through example apps.
	</para>
	<section id="docker:goal">
		<title>Why Docker?</title>
		<para>
			Prior to UCS 4.1, Apps in the Univention App Center were installed next to all other system packages. This made the development
			of enterprise applications for UCS fairly easy but had some shortcomings:
			<itemizedlist>
				<listitem><simpara>
					Some applications required newer versions of certain packages like PHP. This had impact on the stability
					of the operating system and also led to (not obvious) conflicts between apps.
				</simpara></listitem>
				<listitem><simpara>
					With a growing number of apps in the App Center catalog it got harder for Univention to verify that the
					App did not break anything by enabling/disabling features of certain software components. With the Debian
					Maintainer scripts, App vendors had effectively root access on the system.
				</simpara></listitem>
			</itemizedlist>
			By supporting Docker, we aim to overcome those points while preserving the simplicity of developing an App.
		</para>
		<para>
			If you have already worked with Docker, you may know that Docker is sometimes advertised as a way to encapsulate each and
			every task into its own container, sometimes referred to as <firstterm>Micro services</firstterm>. In the Univention App Center
			we currently focus on a different route: We start minimal, yet fully functional UCS systems in which one App is installed
			and started.
			<important>
				<para>
					For App development this means that an ISV still programs against a UCS. There is no need to build a dedicated
					Docker Container. Univention already provides such a container along with the tools to actually install
					Debian packages just like the App would be installed <phrase>on metal</phrase> (or just like it was prior to UCS 4.1).
				</para>
				<para>
					An ISV needs to provide Debian packages, not Docker images (very much the same as in UCS &lt; 4.1). The integration
					of the App into the UCS infrastructure may be done via an additional package or via separate scripts that live
					unpackaged on the App Center server (see below for an example).
				</para>
			</important>
		</para>
	</section>
	<section id="docker:example">
		<title>Example: Docker App <application>Radicale</application></title>
		<para>
			In this section we will develop a Docker based App step by step.
		</para>
		<para>
			We use the software <application>Radicale</application> for it.
			<application>Radicale</application> is a CardDAV and CalDAV server already packaged in Debian and therefore available in UCS.
			So we do not really develop something from scratch but use an existing application and put it into the Univention App Center.
		</para>
		<note><para>
			In general, apps need to come in the Debian package format (<filename class="extension">.deb</filename>).
			If you do not have your application packaged in this way, you may want to check
			the chapter <ulink url="https://docs.software-univention.de/developer-reference.html#chap:packaging">packaging</ulink> in the UCS developer reference
			as a starting point.
			Here we will use a pre packaged application already present in (the unmaintained repository of) UCS.
		</para></note>
		<section id="docker:example:prerequisites">
			<title>Prerequisites</title>
			<para>
				You need a running UCS 4.1 system (&ucsMaster; for the sake of convenience).
				As <application>Radicale</application> will be installed from the UCS repository, not from the App Center and <application>Radicale</application> is unmaintained by Univention, you need to activate the unmaintained repository:
				<programlisting language="sh"><![CDATA[ucr set repository/online/unmaintained='yes']]></programlisting>
				Also, make sure your system has the following packages installed:
				<simplelist type="inline">
					<member><package>univention-appcenter</package></member>
					<member><package>univention-appcenter-docker</package></member>
					<member><package>univention-appcenter-dev</package></member>
				</simplelist>
			</para>
			<para>
				After this has been done, run
				<programlisting language="sh"><![CDATA[univention-app dev-setup-local-appcenter]]></programlisting>
			</para>
		</section>
		<section id="docker:example:ini">
			<title>The ini file</title>
			<para>
				An App consists of the actual packages and meta information about the App.
				The App <emphasis>may</emphasis> ship one or more screenshots, various <filename>README</filename> files and so on.
				But every App <emphasis>has</emphasis> to have an <filename class="extension">ini</filename> file.
			</para>
			<important><para>
				Every version of an App (i.e. the original upload and every update of it) has its own <filename class="extension">ini</filename> file!
				It may be just a copy of the original file with the <option>Version=</option> increased, yet a new ini file is necessary.
			</para></important>
			<para>
				Create a file <filename>~/radicale.ini</filename> (name it as you like...) and put the very first content in it:
				<programlisting language="ini">
[Application]
# Can be chosen arbitrarily but after it has been chosen,
# needs to stay the same in each version
ID=radicale
# Code is necessary, but given by Univention. Normally, you do not
# need to specify it
Code=RD
Name=Radicale
				</programlisting>
				The version will be set to that of the repository:
				<programlisting language="ini">
Version=0.7
				</programlisting>
				<application>Radicale</application> is developed by <wordasword>Kozea</wordasword>, we are "only" doing the integration work.
				If you develop the software and do the integration, you only need the first two lines:
				<programlisting language="ini">
Vendor=Kozea
WebsiteVendor=http://kozea.fr/
Maintainer=Univention
WebsiteMaintainer=http://www.univention.de/
				</programlisting>
				<application>Radicale</application> can be used to manage shared calendars, so this makes it a Collaboration App:
				<programlisting language="ini">
Categories=Collaboration
				</programlisting>
				<note><para>
					The following categories are allowed (multiple can be specified, separated by ","):
					Administration, Business, Collaboration, Education, System services, <wordasword>Virtualization</wordasword> (+ UCS Components, but these are meant for Univention Software)
				</para></note>
				Now the important parts:
				The Debian package that is to be installed is called <package>radicale</package>.
				It will live in a repository created for this App on the App Center server.
				The package is unmaintained by Univention, so it needs to be copied from the unmaintained repository to the App's repository (this is done later).
				<programlisting language="ini">
DefaultPackages=radicale
				</programlisting>
				It shall be installed as a Docker App, so the following needs to be specified:
				<programlisting language="ini">
DockerImage=docker.software-univention.de/ucs-appbox-amd64:4.1-0
				</programlisting>
				This means that the package is not installed on your system but rather in a Docker Container running on your system.
				To access the relevant bits of the container (i.e. the calendars and contacts), you need to forward the port (which happens to be 5232 for <application>Radicale</application>):
				<programlisting language="ini">
PortsExclusive=5232
# You could also use PortsRedirection=1234:5232
				</programlisting>
				<note><para>
					Univention provides a set of images at <uri>docker.software-univention.de</uri>, at least one per minor version of UCS.
					If unsure, it is probably a good idea to have the image's UCS version match the UCS version of the Docker Host.
					But this is absolutely not mandatory.
					In fact, it is one of the advantages of Docker apps that their OS may differ from the host's.
					For a list of the images, ask Univention.
				</para></note>
			</para>
			<para>
				Together, this makes:
				<programlisting language="ini"><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="radicale.ini0" parse="text"/></programlisting>
				Finally, put the ini file into the (local) App Center (do not forget to upload the Debian packages - here this means two unmaintained packages already built):
				<programlisting language="sh"><![CDATA[
univention-app dev-populate-appcenter --new \
	--ini ~/radicale.ini \
	--unmaintained radicale python-radicale
]]></programlisting>
			</para>
		</section>
		<section id="docker:example:integration1">
			<title>Integration, first iteration</title>
			<para>
				<application>Radicale</application> should already be installable.
				Alas, it will not work.
				This is due to the way <application>Radicale</application> is packaged in Debian.
				To make it work as expected, we need to modify it.
				Here starts the integration work of the App.
			</para>
			<para>
				First of all, <application>Radicale</application> is not started by default.
				To change that, we need to modify <filename>/etc/default/radicale</filename> and uncomment <literal>#ENABLE_RADICALE</literal>.
				The Univention App Center supports various scripts that can be added to the App and will be executed at various points in time.
				Maybe the most important one is the join script.
			</para>
			<section id="docker:example:join">
				<title>The join script</title>
				<para>
					The join script is a fundamental feature of UCS.
					UCS is used to run and administrate a domain.
					New computers may "join" the domain.
					The computer searches for the Domain Controller Master (DC Master) and adds itself to LDAP (hostname, IP address, etc).
					Join scripts are used to "join software packages" into the domain.
					This means that if you install, say, <package>radicale</package>, it may need to register <application>Radicale</application> somewhere and make some changes in the domain.
				</para>
				<para>
					The domain is administrated by manipulating the core database on the DC Master, the LDAP database.
					Normally, this is done by using tools provided by Univention, mainly the Univention Directory Manager, <command>udm</command>.
				</para>
				<para>
					But here, we do not really need to alter LDAP.
					We just want to change a local file.
					We are just making use of the fact that the join script is executed after the package is installed.
					(In terms of the App Center: after the App is installed)
				</para>
				<note><para>
					We need to distinguish between the <emphasis>Docker Host</emphasis> - this is the "real" UCS installed.
					The Docker Host is running the <emphasis>Docker Container</emphasis>s.
					These may also be UCS systems, but they essentially only run the App packages.
				</para></note>
				<para>
					The App Center provides an easy way to add a join script to the App by just adding it to the repository on the App Center server.
					The join script is then executed on the <emphasis>Docker Host</emphasis> after the <emphasis>Docker Container</emphasis> is set up.
					So the join script is not executed locally with respect to the App, but the Docker Host may access the file system of the Container anyway.
				</para>
				<para>
					To add a join script, just create a file <filename>~/radicale.inst</filename> and add the following to it:
					<programlisting language="sh"><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="radicale.inst0" parse="text"/></programlisting>
					Now you can add it to the App Center:
					<programlisting language="sh"><![CDATA[
univention-app dev-populate-appcenter --new \
	--ini ~/radicale.ini \
	--join ~/radicale.inst \
	--unmaintained radicale python-radicale
	]]></programlisting>
				</para>
				<note><para>
					<programlisting language="sh"><![CDATA[univention-app dev-populate-appcenter --new]]></programlisting>
					will create a new version of the App and write the internal component to the screen
					(In this case something like <literal>radicale_<replaceable>yyyymmdd</replaceable></literal>).
					But if you are fast enough, it will overwrite the existing App version because the date does not (yet) differ.
					Correct would be something like
					<programlisting language="sh"><![CDATA[
univention-app dev-populate-appcenter \
	--component radicale_20150929 \
	--join ~/radicale.inst
]]></programlisting>
					to really alter the App.
				</para></note>
			</section>
			<section id="docker:example:store">
				<title>Storing the data persistently</title>
				<para>
					Now the App should be installable and run as expected.
					As specified in the ini	<filename>ucs-appbox-amd64:4.1-0</filename> will be used
					as the Docker image. It is downloaded from a docker registry set up at Univention and started on the Docker Host.
					The image contains a minimal UCS member server which will eventually contain the App packages.
				</para>
				<important><para>
					There are some things you should be aware of when developing a Docker App for the Univention App Center:
					<itemizedlist>
						<listitem><simpara>
							The default image is a minimal, yet fully functional UCS.
						</simpara></listitem>
						<listitem><simpara>
							The system will join into the domain.
							The Docker App will be listed as a member server when showing all hosts of the domain.
						</simpara></listitem>
						<listitem><simpara>
							The system will not run something like <filename>/usr/bin/radicale</filename> directly.
							Instead it runs <command>/sbin/init</command> (it is actually a slightly altered version of the original <command>/sbin/init</command> of UCS).
							The App will be run because it is somehow configured to be started on a certain run-level (somehow means: This is the job of the corresponding Debian package).
						</simpara></listitem>
						<listitem><simpara>
							The Docker image is writable, i.e. the App can create and modify all files it wants and after restarting the container, the files persist.
							This also holds for updates: The Docker Container may install package updates released by Univention (so called errata updates) and even new major versions of the operating system.
							This means that the image can be used "forever".
						</simpara></listitem>
					</itemizedlist>
				</para></important>
				<para>
					Last point for this section will be storing and restoring data from the Docker Container.
					Although the container may be used forever, it may be that the underlying image needs to be exchanged.
					This is done by effectively removing the old container and setting up a completely new one.
					Thus, we need to store the App data just before removing the old container and restore it in the new one.
				</para>
				<para>
					<application>Radicale</application> has some backends where to store the data, but preconfigured is the file backend - which makes it very easy for us to backup the data.
					The calender and contact data is stored at <filename class="directory">/var/lib/radicale/collections/</filename>.
					We just need to save this directory and restore it accordingly.
					Luckily, the Univention App Center provides a shared directory where the App can store its data easily.
					This directory is <filename class="directory">/var/lib/univention-appcenter/apps/<replaceable>$APPID</replaceable>/data/</filename>.
				</para>
				<para>
					Create the file <filename>~/radicale.store_data</filename> with the following content:
					<programlisting language="sh"><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="radicale.store_data" parse="text"/></programlisting>
					Next, create <filename>~/radicale.restore_data</filename>:
					<programlisting language="sh"><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="radicale.restore_data" parse="text"/></programlisting>
				</para>
				<important><para>
					<filename class="directory">/var/lib/univention-appcenter/apps/<replaceable>$APPID</replaceable>/data/</filename> is always mounted into the Docker Container.
					The very same directory exists on the Docker Host. If your App can be configured to save its data on a different location, you may want to consider
					using this directory. Not only will it make storing and restoring data in the image exchange process very easy, it should also be faster because
					it does not rely on the Docker storage driver, thereby reducing overhead. In fact, <application>Radicale</application> should have been configured
					to store its collection data there in the first place instead of copying it in <filename>store_data</filename>. But this would render the script useless and it shall be part
					of the tutorial!
				</para></important>
				<para>
					Finally, make these scripts known to the App by specifying them in the ini file.
					You can use any name you like.
					The scripts will be copied to that place in the container.
					You may even overwrite existing files.
					<programlisting language="ini">
DockerScriptStoreData=/usr/share/univention-appcenter/app/radicale/store_data
DockerScriptRestoreDataAfterSetup=/usr/share/univention-appcenter/app/radicale/restore_data
					</programlisting>
				</para>
				<note><para>
					All Docker scripts that may be specified in the ini file have a reasonable default already installed in the default container.
					So it is generally a good idea to execute the default script in your script.
				</para></note>
				<warning><para>
					When using custom scripts (like <filename>store_data</filename>) you should also set the corresponding <envar>DockerScript</envar>
					variable in the ini file. The default of this variable is the path to the default script. If you want to run that default script in
					your custom script (as advised)	you will instead call yourself!
				</para></warning>
				<para>
					Add the new scripts to your App Center:
					<programlisting language="sh"><![CDATA[
univention-app dev-populate-appcenter --new \
	--ini ~/radicale.ini \
	--join ~/radicale.inst \
	--store-data ~/radicale.store_data \
	--restore-data-after-setup ~/radicale.restore_data \
	--unmaintained radicale python-radicale
]]></programlisting>
				</para>
			</section>
		</section>
		<section id="docker:example:integration2">
			<title>Integration, second iteration</title>
			<para>
				The App should be in a functional state now.
				<programlisting language="sh"><![CDATA[univention-app install radicale]]></programlisting>
				should give you a running CalDAV/CardDAV service at port 5232 on your Docker Host.
			</para>
			<para>
				The configuration of the service is not optimal, though.
				Every user, even an anonymous user can create and change any calender and contact.
				We want to limit the access to domain users.
				And they should only be able to change their own calendars.
				Note that <application>Radicale</application> provides mechanisms for even finer grained control.
				This is not scope of this example, though.
			</para>
			<section id="docker:example:ucr">
				<title>Making the App configurable by the user</title>
				<para>
					<application>Radicale</application>'s rights management can be configured in various ways.
					We want to
					let the administrator decide whether the App's configuration is <envar>owner_write</envar> (users
					need to have valid credentials; their own calenders/contacts can be modified,
					others' can be read) or <envar>authenticated</envar> (same, but others' can also be modified).
				</para>
				<para>
					This is achieved by adding <filename>~/radicale.ucr</filename>.
					This file defines some Univention Configuration Registry variables (UCR).
					These are a core feature of UCS and thus of a Docker App based on UCS.
					<programlisting language="ini"><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="radicale.ucr" parse="text"/></programlisting>
				</para>
				<para>
					The definition itself is not very useful on its own.
					It just sets the variable in the database.
					The interesting part of UCR are the triggers and the templates.
					One may define triggers that are executed whenever a variable is changed.
					And one may define templates that overwrite existing files depending on UCR variables.
				</para>
				<para>
					Normally, one would now create a package with all the triggers.
					But for this example, we do not want to create packages at all.
					We may abuse the join script to add this trigger and a template in the container.
				</para>
				<note><para>
					The integration part starts getting complicated.
					One should really create a package <package>univention-radicale</package> and add the UCR definition there.
					One could also do the modification of <filename>/etc/default/radicale</filename> there, e.g. by using <command>dpkg-divert</command>.
					The package would depend on exactly one package (<package>radicale</package>) and be defined as the only <envar>DefaultPackages</envar> in the ini file.
				</para></note>
				<para>
					We will show what to do in the next section as the join script is modified one more time.
				</para>
			</section>
			<section id="docker:example:ldap">
				<title>Making the App LDAP aware</title>
				<para>
					<application>Radicale</application> comes with LDAP support.
					We just need to configure it.
					<application>Radicale</application> binds to LDAP and can then check any credentials.
					But for that we need a <literal>binddn</literal> for <application>Radicale</application>.
					A new user for that App needs to be created in LDAP.
				</para>
				<para>
					After that this very user has to be specified in the configuration file
					of <application>Radicale</application>, <filename>/etc/radicale/conf</filename>.
				</para>
				<para>
					This should be done in the join script.
					We change <filename>~/radicale.inst</filename> so that it adds a new user for us and creates a file in the container.
					Note that the latter operation is quick and dirty and is only done because we would have to create a package for basically one file otherwise.
					<programlisting language="sh"><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="radicale.inst" parse="text"/></programlisting>
					Note that <command>ucs_addServiceToLocalhost</command> was added.
					This is a best practice to
					make the domain administrator aware where the application <application>Radicale</application> is installed.
				</para>
				<important><para>
					The command <command>ucs_addServiceToLocalhost</command> should be reverted when the App is uninstalled.
					But even more importantly, the join script needs to be run again as soon as the App is uninstalled and then installed again (changing <filename>/etc/default/radicale</filename> and so on...).
					As the join script saved the information bit that it was successfully executed at the end of itself, we need to revert that, too.
					To do so, we need an <emphasis>unjoin script</emphasis>.
					Technically it is similar to a join script but run after uninstalling the App, not after installing it.
					The script would simple do this (save to <filename>~/radicale.uinst</filename>):
					<programlisting language="sh"><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="radicale.uinst" parse="text"/></programlisting>
				</para></important>
				<para>
					One last time we need to update our App Center server:
					<programlisting language="sh"><![CDATA[
univention-app dev-populate-appcenter --new \
	--ini ~/radicale.ini \
	--join ~/radicale.inst \
	--unjoin ~/radicale.uinst \
	--store-data ~/radicale.store_data \
	--restore-data-after-setup ~/radicale.restore_data \
	--ucr ~/radicale.ucr \
	--unmaintained radicale python-radicale
]]></programlisting>
				</para>
				<para>
					Now we can test and use our application:
					<programlisting language="sh"><![CDATA[univention-app install radicale]]></programlisting>
				</para>
				<para>
					The configuration option regarding the rights management can now be set in the &ucsUMC; or via
					<programlisting language="sh"><![CDATA[
univention-app configure radicale \
	--set radicale/rights/type=authenticated
univention-app restart radicale
]]></programlisting>
				</para>
			</section>
		</section>
	</section>
	<section id="docker:epilogue">
		<title>Epilogue</title>
		<para>
			In this section we will go briefly over things we may have missed in the example.
		</para>
		<section id="docker:epilogue:scripts">
			<title>Docker scripts</title>
			<para>
				For every App, the App Center server holds a repository containing the Debian packages. But it also may hold
				several scripts that do not need to be packaged. In theory one may integrate one's App without needing to
				build an additional integration package. That being said, with increasing complexity, it is advised to build
				such a package nonetheless. Furthermore, not everything can be achieved easily with these scripts. There are
				interfaces rarely used that the App Center does not support. Should your App require these interfaces, it may
				be necessary to create a package.
			</para>
			<para>
				We need to distinguish between <emphasis>outer scripts</emphasis> and <emphasis>inner scripts</emphasis>. An
				<emphasis>outer script</emphasis> is called on the <emphasis>Docker Host</emphasis>, <emphasis>inner scripts</emphasis>
				are called in the running <emphasis> Docker Container</emphasis>.
			</para>
			<para>
				All scripts are called with root privileges. For <emphasis>inner scripts</emphasis> this means the local root
				of the <emphasis>Docker Container</emphasis>. Some scripts may get LDAP credentials. Normally these credentials
				are that of the <emphasis>Administrator account</emphasis>.
			</para>
			<note><para>
				None of the following scripts is mandatory, all have reasonable defaults / fall-backs. But every scripts may be
				overridden! Just upload them along with the ini file and Univention will place them on the App Center server.
				See also <xref linkend="docker:epilogue:ini" /> on how to specify these scripts in the ini file.
			</para></note>
			<para>
				The following scripts are for installation and uninstallation. Upgrades use these scripts, too, if (and only if)
				the upgrade includes an image exchange (i.e. the new version with the new ini file specifies a different
				<envar>DockerImage</envar>). In that case the old App is uninstalled and the new App is installed.
			</para>
			<variablelist>
				<varlistentry>
					<term><filename>preinst</filename></term>
					<listitem>
						<simpara>
							An <emphasis>outer script</emphasis> called before the Docker Container is initialized, even
							before the image is downloaded. Its purpose is to check whether installation may be successful.
							For example, the preinst may fail if certain hardware requirements are not met. Any exit code
							other than 0 will result in cancellation of the installation process.
							If the installation of an App is the result of an image exchange (and thus more of an upgrade)
							the preinst is also called.
						</simpara>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><filename>restore_data_before_setup</filename></term>
					<listitem>
						<simpara>
							An <emphasis>inner script</emphasis> called before <emphasis>setup</emphasis> is called, right after
							the container is started. Its purpose is to restore those bits that may be needed to successfully
							run the setup script. May be useful in an upgrade process where one needs to restore the state the old
							container was in instead of setting up the container as if it were fresh.
						</simpara>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><filename>setup</filename></term>
					<listitem>
						<simpara>
							An <emphasis>inner script</emphasis> and heart of the whole installation process. By default it joins the system,
							(a script called <command>univention-join</command> provided by Univention), adds the repository that was created
							on the App Center server and installs <envar>DefaultPackages</envar> specified in the ini file.
							After that it once again joins, running all scripts that may have been installed during the App installation.
							If the script fails (exit code != 0) the installation is aborted.
						</simpara>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><filename>restore_data_after_setup</filename></term>
					<listitem>
						<simpara>
							An <emphasis>inner script</emphasis> called after <emphasis>setup</emphasis> is called. Its purpose
							is to actually restore the data that may have been saved in <emphasis>store_data</emphasis> â€“ now that
							the App is up and running but the database is still empty.
						</simpara>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><filename>inst</filename></term>
					<listitem>
						<simpara>
							Also called <emphasis>join script</emphasis>. An <emphasis>outer script</emphasis> called after the
							<emphasis>Docker Container</emphasis> is configured. Think of it as a postinst of the App.
							See the <ulink url="https://docs.software-univention.de/developer-reference.html#join:write">Developer
							Reference</ulink> for how to write a join script. If the join script runs successfully, the join script
							may save this information in a status file. If this does not happen, the user is constantly
							reminded to re-run the join script. So the join script does not need to run successfully. The installation
							will not be aborted at this point. But of course at some point it should run through successfully.
							The main purpose of the join script is to set up the domain for the new App, e.g. by adding a domain
							user that can be used as the <literal>LDAP binddn</literal> that your App may need to authenticate
							against the central user management of UCS.
						</simpara>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><filename>prerm</filename></term>
					<listitem>
						<simpara>
							An <emphasis>outer script</emphasis> called before the Docker Container is removed.
							Its purpose is to check whether an uninstallation may be successful. But it may
							be used to somehow prepare the system for the uninstallation.
							For example, the prerm may fail if other software still depends on it. Any exit code
							other than 0 will result in cancellation of the uninstallation process.
						</simpara>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><filename>store_data</filename></term>
					<listitem>
						<simpara>
							An <emphasis>inner script</emphasis> called before removing the
							<emphasis>Docker Container</emphasis>. In fact the App is not really uninstalled.
							The container is just thrown away. This also happens during image upgrades: The
							current image is thrown away and a new image is set up. Therefore it is important
							to store the data of the current App to be able to start into exactly that state
							when the container was removed.
							You may call any App specific commands like <command>myapp-backup --full</command>
							or just copy the important files. The App Center always mounts the following
							directory into the container, which can be used to store the data (and later
							restore the data from there as the very same directory will be mounted into the
							new container): <filename class="directory">/var/lib/univention-appcenter/apps/<replaceable>$APPID</replaceable>/data/</filename>.
						</simpara>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><filename>uinst</filename></term>
					<listitem>
						<simpara>
							Also called <emphasis>unjoin script</emphasis>. An <emphasis>outer script</emphasis> called after the
							<emphasis>Docker Container</emphasis> is removed. Think of it as a postrm of the App.
							See the <ulink url="https://docs.software-univention.de/developer-reference.html#join:write">Developer
							Reference</ulink> for how to write an unjoin script. It should somehow revert most (if not all) changes done
							in the <emphasis>inst</emphasis> script (or join script). With the notable exception of schema
							registration. An LDAP schema extension should never be removed once it was registered.
						</simpara>
					</listitem>
				</varlistentry>
			</variablelist>
			<para>
				The following scripts are for upgrading the software within the <emphasis>Docker Container</emphasis>. Three possible
				scenarios have to be covered:
				<itemizedlist>
					<listitem><simpara>
						Upgrade of system packages (security fixes, UCS calls them Errata Updates)
					</simpara></listitem>
					<listitem><simpara>
						Upgrade of the operating system (a new patchlevel release or even a minor/major update of UCS (4.1-1 or 4.2-0)
					</simpara></listitem>
					<listitem><simpara>
						Upgrade of App packages, i.e. a new version (with the same <literal>DockerImage</literal>) was released
					</simpara></listitem>
				</itemizedlist>
			</para>
			<variablelist>
				<varlistentry>
					<term><filename>update_available</filename></term>
					<listitem>
						<para>
							An <emphasis>inner script</emphasis> called when the App Center wants to find out whether the
							container may install package updates or release updates. By default, this is done automatically
							once a day. It can be triggered manually, too, though.
							The script needs to <command>echo</command> the result:
							<itemizedlist>
								<listitem><simpara>
									<emphasis>packages</emphasis> if mere package updates are available. These include
									security fixes for operating system packages.
								</simpara></listitem>
								<listitem><simpara>
									<emphasis>release: <replaceable>RELEASE</replaceable></emphasis> if a new version
									of the operating itself is available. <replaceable>RELEASE</replaceable> can be anything,
									it is just presented to the user.
								</simpara></listitem>
							</itemizedlist>
							<note><para>
								The script does not search for App updates, nor does it search for a change in the <envar>DockerImage</envar>!
								This is done by the "outer" App Center.
							</para></note>
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><filename>update_packages</filename></term>
					<listitem>
						<simpara>
							An <emphasis>inner script</emphasis> called when (all) updates of existing packages shall be installed.
						</simpara>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><filename>update_release</filename></term>
					<listitem>
						<simpara>
							An <emphasis>inner script</emphasis> called when a new version of the operating system shall be installed.
						</simpara>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><filename>update_app_version</filename></term>
					<listitem>
						<simpara>
							An <emphasis>inner script</emphasis> called when a new version of the App packages shall be installed.
							This script is different from <literal>update_packages</literal>. This has technical reasons, because
							for normal UCS based Docker images, this requires a new repository to be registered. But it also has
							usability reasons: First, users may want to distinguish between necessary, stability improving package
							updates and (potentially) ground-shaking App updates; second, at least the UCS containers are configured
							to install security / stability updates automatically.
						</simpara>
					</listitem>
				</varlistentry>
			</variablelist>
		</section>
		<section id="docker:epilogue:ini">
			<title>Docker related variables in the ini file</title>
			<para>
				We used some of the ini's variables to adjust the Docker App to our needs. Here is a brief overview regarding all Docker related
				variables:
				<variablelist>
					<varlistentry>
						<term><varname>DockerImage</varname></term>
						<listitem>
							<para>
								The image the container will be based on. The Univention App Center will provide a list of
								UCS based images that can be used to run the application. Other images may work but are strongly
								discouraged as they will lack domain functionality that would be required to integrate the App
								into the UCS domain.
								<note><simpara>
									If you want to develop a Docker App, this variable is <emphasis>required</emphasis>.
									The following variables on the other hand have meaningful defaults (or are empty, which is
									fine, too).
								</simpara></note>
							</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><varname>DockerAllowedImages</varname></term>
						<listitem>
							<simpara>
								When the App does not rely on a well defined basis, it may be convenient to update <literal>DockerImage</literal>
								every now and then (e.g. when a new minor version of UCS is released). This is not required, but not doing so
								would configure an outdated base image that needs to be upgraded after the App installation. This may take
								a long time depending on the age of the image.
							</simpara>
							<simpara>
								If <literal>DockerImage</literal> is changed, the App Center recognizes this and will exchange the image
								by removing the container and setting up a new one. This is of course not necessary for an old, but
								constantly updated image. So one can put the old image name in the <literal>DockerAllowedImages</literal>
								list and the App Center will accept it. New apps will be installed with <literal>DockerImage</literal>, though.
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><varname>DockerVolumes</varname></term>
						<listitem>
							<simpara>
								Apart from <filename class="directory">/var/lib/univention-appcenter/apps/<replaceable>$APPID</replaceable>/{data,conf}/</filename>,
								one may choose further directories that shall be mounted into the Docker Container. This is a good idea if it makes
								storing / restoring data easy and also provides the benefit of increased I/O performance. The syntax is
								<envar>DockerVolumes=/path/on/host/:/path/in/container/,...</envar>.
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><varname>DockerServerRole</varname></term>
						<listitem>
							<simpara>
								The Univention App Center adds a computer object for the container in the LDAP database. This computer
								object can either be a <envar>memberserver</envar> (default) or a <envar>domaincontroller_slave</envar>.
								The latter is useful if the container needs more rights (DC systems may have more rights in the ACL definitions
								of LDAP). Other than that, both roles are free to choose their software selection (depending on the App package
								definitions in its <filename>debian/control</filename>).
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><varname>DockerScript</varname>*</term>
						<listitem>
							<simpara>
								The various <varname>DockerScript<replaceable>*</replaceable></varname> variables are used to specify the path to the script that shall
								be executed. So an App package may ship its own <literal>DockerScriptStoreData</literal> and the ini file
								can point to it. More importantly though, the App can ship these scripts unpackaged along with the ini file
								and the App Center will install these scripts at that destination and then call it. See <xref linkend="docker:epilogue:scripts" /> for a brief
								overview over the scripts. The name in the ini file for <filename>store_data</filename> is
								<literal>DockerScriptStoreData</literal> and so on.
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><varname>PortsExclusive</varname></term>
						<listitem>
							<simpara>
								Not really limited to Docker Apps, but this variable will be essential to make your Docker App work: It specifies
								a comma separated list of ports that the Docker Container shall expose publicly. If your App opens port, say, 3000,
								you need to specify that in the ini file, otherwise the port will not be accessible from any host but the Docker
								Container itself. The Docker Host will configure the container according to this variable on startup. By default, no
								port is exposed. One exception is a port to a <varname>WebInterface</varname> (also to be specified in the ini file)
								which is handled automatically by the Univention App Center.
							</simpara>
								<note><simpara>
									<package>univention-firewall</package> on the Docker Host will be reconfigured automatically to allow
									connections to these ports.
								</simpara></note>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><varname>PortsRedirection</varname></term>
						<listitem>
							<simpara>
								Just like <varname>PortsExclusive</varname> but with an the option to map the local port to one other port on the Docker Host. Useful
								when exposing a service that is used commonly and therefore will generate port conflicts. E.g., if your App shall be accessible via SSH,
								you cannot exclusively claim port 22. But you can specify <varname>PortsRedirection=10022:22</varname>.
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><varname>WebInterface</varname></term>
						<listitem>
							<simpara>
								Not exclusive to Docker Apps, but a bit different as to what happens in the background: If your App provides a web interface
								(e.g., <uri>/radicale/</uri>), you can specify it here. In this case, the Univention App Center will automatically make the Docker Container's
								web interface publicly accessible by using <package>mod_proxy</package> of <package>apache</package> (using the port range 40000
								up to 41000, controlled by the Univention App Center itself).
							</simpara>
								<note><simpara>
									The proxy entry in the Apache configuration will be something like:
								</simpara>
									<programlisting><![CDATA[ProxyPass /radicale http://127.0.0.1:40000/radicale]]></programlisting>
								<simpara>
									where the port 40000 is mapped to Docker Container's port <varname>WebInterfacePortHTTP</varname> (which defaults to 80).
									So your App needs to make <uri>/radicale/</uri> accessible, too. Note that there will be a separate entry for HTTPS, too.
								</simpara></note>
								<note><simpara>
									HTTP or HTTPS access can be disabled by specifying <varname>WebInterfacePortHTTP=0</varname>
									(<varname>WebInterfacePortHTTPS</varname> respectively).
								</simpara></note>
						</listitem>
					</varlistentry>
				</variablelist>
				Please refer to the <ulink url="https://docs.software-univention.de/developer-reference.html#app:iniFile">Developer Reference</ulink>
				for a template and the description of every attribute in the ini file.
			</para>
		</section>
	</section>
	<section id="docker:debugging">
		<title>Debugging</title>
		<para>
			So you developed the App, put it into the App Center and now that you want to test it, something fails? If something goes
			wrong really badly (like the installation of packages fails), the App Center reverts the installation (i.e. it removes the
			container). This means you cannot look into it to see what exactly happened. For testing purposes you may use the undocumented
			options <option>--do-not-revert</option> (still using <application>Radicale</application>):
			<programlisting language="sh"><![CDATA[univention-app install radicale --do-not-revert]]></programlisting>
			This will leave you with a running, yet somewhat "unconfigured" container. You may now login into this container by doing
			<programlisting language="sh"><![CDATA[docker ps -a]]></programlisting>
			which will list your container. Find the container and call:
			<programlisting language="sh"><![CDATA[docker exec -it "$CONTAINER "/bin/bash]]></programlisting>
			Normally you should be able to do this without finding the container by hand:
			<programlisting language="sh"><![CDATA[
CONTAINER="$(ucr get appcenter/apps/radicale/container)"
docker exec -it "$CONTAINER" /bin/bash
]]></programlisting>
			From here you can debug the system as normal.
		</para>
		<para>
			Maybe it is sufficient to look into the log files to know what went wrong. Important log files are:
			<itemizedlist>
				<listitem><simpara>
					<filename>/var/log/univention/appcenter.log</filename>
				</simpara></listitem>
				<listitem><simpara>
					<filename>/var/log/univention/management-console-module-appcenter.log</filename> (if you installed the App via the UMC module - which
					is actually a good idea as users will install it that way, too).
				</simpara></listitem>
				<listitem><simpara>
					<filename>/var/log/docker.log</filename>
				</simpara></listitem>
			</itemizedlist>
		</para>
	</section>
</chapter>

<!-- vim:set ts=2 sw=2 tw=0 noet ft=docbk spelllang=en_gb spell:-->
