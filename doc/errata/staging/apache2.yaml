product: ucs
release: "4.4"
version: [9]
scope: ucs_4.4-0-errata4.4-9
src: apache2
fix: 2.4.25-3+deb9u19A~4.4.9.202410062011
desc: |
 This update addresses the following issues:
 * CVE-2024-38474: Substitution encoding issue in `mod_rewrite` in Apache HTTP
   Server allows attacker to execute scripts in directories permitted by the
   configuration but not directly reachable by any URL or source disclosure of
   scripts meant to only to be executed as CGI. Some `RewriteRules` that
   capture and substitute unsafely will now fail unless rewrite flag
   `UnsafeAllow3F` is specified.
 * CVE-2024-38475: Improper escaping of output in `mod_rewrite` in Apache HTTP
   Server allows an attacker to map URLs to filesystem locations that are
   permitted to be served by the server but are not intentionally/directly
   reachable by any URL, resulting in code execution or source code
   disclosure. Substitutions in server context that use a backreferences or
   variables as the first segment of the substitution are affected. Some
   unsafe `RewiteRules` will be broken by this change and the rewrite flag
   `UnsafePrefixStat` can be used to opt back in once ensuring the
   substitution is appropriately constrained.
 * CVE-2024-36387: Serving WebSocket protocol upgrades over a HTTP/2
   connection could result in a Null Pointer dereference, leading to a crash
   of the server process, degrading performance.
 * CVE-2024-38476: Vulnerability in core of Apache HTTP Server are vulnerably
   to information disclosure, `SSRF` or local script execution via backend
   applications whose response headers are malicious or exploitable.
 * CVE-2024-38477: null pointer dereference in mod_proxy in Apache HTTP Server
   allows an attacker to crash the server via a malicious request.
 * CVE-2024-38573: In the Linux kernel, the following vulnerability has been
   resolved: `cppc_cpufreq`: Fix possible null pointer dereference
   `cppc_cpufreq_get_rate()` and `hisi_cppc_cpufreq_get_rate()` can be called
   from different places with various parameters. So `cpufreq_cpu_get()` can
   return null as 'policy' in some circumstances.
 * CVE-2024-40725: A partial fix for CVE-2024-39884 in the core of Apache HTTP
   Server ignores some use of the legacy content-type based configuration of
   handlers. `AddType` and similar configuration, under some circumstances
   where files are requested indirectly, result in source code disclosure of
   local content.
 * CVE-2024-27316: `HTTP/2` incoming headers exceeding the limit are
   temporarily buffered in nghttp2 in order to generate an informative HTTP
   413 response. If a client does not stop sending headers, this leads to
   memory exhaustion.
 * CVE-2023-45802: When a `HTTP/2` stream was reset (`RST` frame) by a client,
   there was a time window were the request's memory resources were not
   reclaimed immediately. Instead, de-allocation was deferred to connection
   close. A client could send new requests and resets, keeping the connection
   busy and open and causing the memory footprint to keep on growing. On
   connection close, all resources were reclaimed, but the process might run
   out of memory before that.
 * CVE-2021-33193: A crafted method sent through `HTTP/2` will bypass
   validation and be forwarded by mod_proxy, which can lead to request
   splitting or cache poisoning.
 * CVE-2020-11993: Apache HTTP Server versions when trace/debug was enabled
   for the `HTTP/2` module and on certain traffic edge patterns, logging
   statements were made on the wrong connection, causing concurrent use of
   memory pools. Configuring the LogLevel of mod_http2 above `info` will
   mitigate this vulnerability for unpatched servers.
 * CVE-2020-9490: Apache HTTP Server versions. A specially crafted value for
   the 'Cache-Digest' header in a `HTTP/2` request would result in a crash
   when the server actually tries to `HTTP/2` PUSH a resource afterwards.
   Configuring the `HTTP/2` feature via `H2Push off` will mitigate this
   vulnerability for unpatched servers.
 * CVE-2023-31122: Out-of-bounds Read vulnerability in mod_macro of Apache
   HTTP Server.
 * CVE-2023-38709: Faulty input validation in the core of Apache allows
   malicious or exploitable backend/content generators to split HTTP
   responses.
 * CVE-2024-24795: HTTP Response splitting in multiple modules in Apache HTTP
   Server allows an attacker that can inject malicious response headers into
   backend applications to cause an HTTP desynchronization attack.
 * CVE-2023-25690: Some `mod_proxy` configurations on Apache HTTP Server allow
   a HTTP Request Smuggling attack.
 * CVE-2022-36760: Inconsistent Interpretation of HTTP Requests ('HTTP Request
   Smuggling') vulnerability in `mod_proxy_ajp` of Apache HTTP Server allows
   an attacker to smuggle requests to the `AJP` server it forwards requests
   to.
 * CVE-2006-20001: A carefully crafted If request header can cause a memory
   read, or write of a single zero byte, in a pool (heap) memory location
   beyond the header value sent. This could cause the process to crash.
 * CVE-2022-37436: Prior to Apache HTTP Server a malicious backend can cause
   the response headers to be truncated early, resulting in some headers being
   incorporated into the response body. If the later headers have any security
   purpose, they will not be interpreted by the client.
 * CVE-2022-26377: Inconsistent Interpretation of HTTP Requests ('HTTP Request
   Smuggling') vulnerability in `mod_proxy_ajp` of Apache HTTP Server allows
   an attacker to smuggle requests to the `AJP` server it forwards requests
   to.
 * CVE-2022-28614: The `ap_rwrite()` function in Apache HTTP Server may read
   unintended memory if an attacker can cause the server to reflect very large
   input using `ap_rwrite()` or `ap_rputs()`, such as with mod_luas `r:puts()`
   function. Modules compiled and distributed separately from Apache HTTP
   Server that use the 'ap_rputs' function and may pass it a very large
   (INT_MAX or larger) string must be compiled against current headers to
   resolve the issue.
 * CVE-2022-28615: Apache HTTP Server may crash or disclose information due to
   a read beyond bounds in ap_strcmp_match() when provided with an extremely
   large input buffer. While no code distributed with the server can be
   coerced into such a call, third-party modules or lua scripts that use
   `ap_strcmp_match()` may hypothetically be affected.
 * CVE-2022-29404: In Apache HTTP Server, a malicious request to a lua script
   that calls `r:parsebody(0)` may cause a denial of service due to no default
   limit on possible input size.
 * CVE-2022-30522: If Apache HTTP Server is configured to do transformations
   with mod_sed in contexts where the input to mod_sed may be very large,
   mod_sed may make excessively large memory allocations and trigger an abort.
 * CVE-2022-30556: Apache HTTP Server may return lengths to applications
   calling `r:wsread()` that point past the end of the storage allocated for
   the buffer.
 * CVE-2022-31813: Apache HTTP Server may not send the `X-Forwarded-*` headers
   to the origin server based on client side Connection header hop-by-hop
   mechanism. This may be used to bypass IP based authentication on the origin
   server/application.
bug: [57628]
cve:
- CVE-2024-38474
- CVE-2024-38475
- CVE-2024-36387
- CVE-2024-38476
- CVE-2024-38477
- CVE-2024-38573
- CVE-2024-40725
- CVE-2024-27316
- CVE-2023-45802
- CVE-2021-33193
- CVE-2020-11993
- CVE-2020-9490
- CVE-2023-31122
- CVE-2023-38709
- CVE-2024-24795
- CVE-2023-25690
- CVE-2022-36760
- CVE-2006-20001
- CVE-2022-37436
- CVE-2022-26377
- CVE-2022-28614
- CVE-2022-28615
- CVE-2022-29404
- CVE-2022-30522
- CVE-2022-30556
- CVE-2022-31813
